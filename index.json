[{"uri":"https://docs.lucidarch.dev/upgrade-guide/micro/","title":"Micro","tags":[],"description":"","content":"Ensure that your tests are passing at the initial state of the upgrade to be able to compare with by the end that you\u0026rsquo;ve received the expected result.\nremove deprecated Lucid packages\ncomposer remove lucid-arch/laravel-foundation lucid-arch/laravel-console\nIt is expected to see failures in the post-script since there are classes that no longer exist\nadd lucidarch/lucid\ncomposer require lucidarch/lucid\nReplace unit namespaces (find \u0026amp; replace in app folder. Additionally you may want to search other folders such as tests):\nJobs\nuse Lucid\\Foundation\\Job; → use Lucid\\Units\\Job;\nOperations\nuse Lucid\\Foundation\\Operation; → use Lucid\\Units\\Operation;\nFeatures\nuse Lucid\\Foundation\\Feature; → use Lucid\\Units\\Feature;\nControllers\nuse Lucid\\Foundation\\Http\\Controller; → use Lucid\\Units\\Controller;\nExceptions\nLucid\\Foundation\\InvalidInputException → Lucid\\Exceptions\\InvalidInputException\nValidator\nuse Lucid\\Foundation\\Validator; → use Lucid\\Validation\\Validator;\nValidation\nuse Lucid\\Foundation\\Validation; → use Lucid\\Validation\\Validation;\nEvents\nuse Lucid\\Foundation\\Events → use Lucid\\Events (without ;)\nReplace traits namespaces\nuse Lucid\\Foundation\\ServesFeaturesTrait; → use Lucid\\Bus\\ServesFeatures;\nuse ServesFeaturesTrait; → use ServesFeatures;\nuse Lucid\\Foundation\\MarshalTrait; → use Lucid\\Bus\\Marshal;\nuse MarshalTrait; → use Marshal;\nRun composer dump-autoload to feel the waters\nThis time it should all be clear of errors. Otherwise, keep digging and replacing until it passes\nRun tests again and expect the same results as in the run before the upgrade\n"},{"uri":"https://docs.lucidarch.dev/concept/","title":"Concept","tags":[],"description":"","content":"This architecture is in an amalgamation of best practices, design patterns and proven methods that we decided to incorporate at the forefront of our code.\nLucid\u0026rsquo;s built-in patterns are Command Bus and Domain Driven Design, upon which it builds a stack of directories and units to organize business logic. It also derives from SOA (Service Oriented Architecture) the notion of encapsulating functionality within a \u0026ldquo;service\u0026rdquo; and enriches the concept with more than the service being a class.\nCommand Bus: to dispatch units of work. In Lucid terminology these units will be a Feature, Job or Operation. Domain Driven Design: to organize the units of work by categorizing them according to the topic they belong to. Service Oriented Architecture: to encapsulate and manage functionalities of the same purpose with their required resources (routes, controllers, views, datatbase migrations etc.) Position In a typical MVC application, Lucid will be the bond between the application\u0026rsquo;s entrypoints and the units that do the work, securing code form meandring in drastic directions:\nThe Stack At a glance\u0026hellip;\nFramework Provides the \u0026ldquo;kernel\u0026rdquo; to do the heavy lifting of the tedious stuff such as request/response lifecycle, dependency injection, and other core functionalities.\nFoundation Extends the framework to provide higher level abstractions that are custom to the application and can be shared across the entire stack rather than being case-specific.\nExamples of what could go into foundation are:\nDateTime a support class for common date and time functions JsonSerializableInterface that is used to identify an object to be serializable from and to JSON format Domains Provide separation to categorize jobs and corresponding classes that belong to the same topic. A domain operates in isolation from other domains and exposes its functionalities to features and operations through Lucid jobs only.\nConsider the structure below for an example on what a domain may look like:\napp/Domains/GitHub ├── GitHubClient ├── Jobs │ ├── FetchGitHubRepoInfoJob │ └── LoginWithGitHubJob ├── Exceptions │ ├── InvalidTokenException │ └── RepositoryNotFoundException └── Tests └── GitHubClientTest └── Jobs ├── FetchGitHubReposJobTest └── LoginWithGitHubJobTest See domains for more details.\nServices Are directories rich in functionality, used to separate a Monolith into areas of focus in a multi-purpose application.\nConsider the example of an application where we enter food recipes and would want our members to have discussions in a forum, we would have two services: 1) Kitchen, 2) Forum where the kitchen would manage all that\u0026rsquo;s related to recipes, and forum is obvious:\napp/Services ├── Forum └── Kitchen and following is a single service\u0026rsquo;s structure, highlighted are the Lucid specific directories:\napp/Services/Forum ├── Console │ └── Commands ├── Features ├── Operations ├── Http │ ├── Controllers │ └── Middleware ├── Providers │ ├── KitchenServiceProvider │ ├── BroadcastServiceProvider │ └── RouteServiceProvider ├── Tests │ └── Features │ └── Operations ├── database │ ├── factories │ ├── migrations │ └── seeds ├── resources │ ├── lang │ └── views └── routes ├── api ├── channels ├── console └── web See services for more on what they contain.\nFeatures Represent a human-readable application feature in a class. It contains the logic that implements the feature but with the least amount of detail, by running jobs from domains and operations at the application or service level.\nServing the Feature class will be the only line in a controller\u0026rsquo;s method (in MVC), consequently achieving the thinnest form of controllers.\nclass AddRecipeFeature extends Feature { public function handle(AddRecipe $request) { $price = $this-\u0026gt;run(new CalculateRecipePriceOperation( ingredients: $request-\u0026gt;input(\u0026#39;ingredients\u0026#39;), ]); $this-\u0026gt;run(new SaveRecipeJob( price: $price, user: Auth::user(), title: $request-\u0026gt;input(\u0026#39;title\u0026#39;), ingredients: $request-\u0026gt;input(\u0026#39;ingredients\u0026#39;), instructions: $request-\u0026gt;input(\u0026#39;instructions\u0026#39;), )); return $this-\u0026gt;run(new RedirectBackJob()); } } See Features for more on serving them as classes from controllers or anywhere else.\nOperations Their purpose is to increase the degree of code reusability by piecing jobs together to provide composite functionalities from across domains.\nclass NotifySubscribersOperation extends Operation { private int $authorId; public function __construct(int $authorId) { $this-\u0026gt;authorId = $authorId; } /** * Sends notifications to subscribers. * * @return int Number of notification jobs enqueued. */ public function handle(): int { $author = $this-\u0026gt;run(GetAuthorByIDJob( id: $this-\u0026gt;authorId, )); do { $result = $this-\u0026gt;run(PaginateSubscribersJob( authorId: $this-\u0026gt;authorId, )); if ($result-\u0026gt;subscribers-\u0026gt;isNotEmpty()) { // it\u0026#39;s a queueable job so it will be enqueued, no waiting time $this-\u0026gt;run(SendNotificationJob( from: $author, to: $result-\u0026gt;subscribers, notification: \u0026#39;article.published\u0026#39;, )); } } while ($result-\u0026gt;hasMorePages()); return $result-\u0026gt;total; } } Operations goes over this simple yet powerful concept.\nData For a scalable set of interconnected data elements, we\u0026rsquo;ve created a place for them in app/Data, because most likely over time writing the application there could develop a need for more than Models in data, such as Repositories, Value Objects, Collections and more.\napp/Data ├── Models ├── Values ├── Collections └── Repositories Benefits There are valuable advantages to what may seem as overengineering.\nOrganization Predictable impact of changes on the system when reviewing code Reduced debugging time since we’re dividing our application into isolated areas of focus (divide and conquer) With Monolith, each of our services can have their own versioning system (e.g. Api service is at v1 while Chat is at v2.3 yet reside) yet reside in the same codebase Reuse \u0026amp; Replace By dissecting our application into small building blocks of code - a.k.a units - we\u0026rsquo;ve instantly opened the door for a high degree of code sharing across the application with Data and Domains, as well as replaceability with the least amount of friction and technical debt.\nBoundaries By setting boundaries you would\u0026rsquo;ve taken a step towards proetcting application code from growing unbearably large and made it easier for new devs to onboard. Most importantly, that you\u0026rsquo;ve reduced technical debt to the minimum so that you don\u0026rsquo;t have to pay with bugs and sleepless nights; code doesn\u0026rsquo;t run on good intentions nor wishes.\nMultitenancy When our application scales we\u0026rsquo;d typically have a bunch of instances of it running in different locations, at some point we would want to activate certain parts of our codebase in some areas and shut off others.\nHere’s a humble example of running Api, Back Office and Web App instances of the same application, which in Lucid terminology are services that share functionality through data and domains:\n"},{"uri":"https://docs.lucidarch.dev/getting-started/micro/","title":"Micro","tags":[],"description":"","content":" The source code for this exercise is on GitHub.\nIn this guide we\u0026rsquo;re going to build a link directory where we can register and save links of our own using Lucid Micro - the default variant for single-purpose applications.\nFor Monolith - the multi-purpose service-oriented variant see Getting Started • Monolith.\nFrom the Lucid stack we\u0026rsquo;d be using Features, Jobs, Domains and Requests to implement the following:\nCreate a form to submit new links. Validate the form. Insert the data into the database. This tutorial is based on the excellent Laravel Tutorial: Step by Step Guide to Building Your First Laravel Application.\nSetup Install Laravel Let\u0026rsquo;s start by creating a new Laravel project. It is best if you refer to Laravel\u0026rsquo;s installation docs and choose your preferred way of installation, but here are the common ways to do it:\n# via the installer laravel new links # via composer composer create-project --prefer-dist laravel/laravel links Install Lucid composer require lucidarch/lucid Database Configuration Now that we have our project ready with a .env file we can configure the database connection.\nFor the brevity of this example we will utilise SQLite as it requires the least steps to get going. This is surely not recommended in real apps but will make very little difference since you can change the configuration and use your favourite database without affecting the code.\nCreate database file storage/app/database/database.sql\nmkdir -p storage/app/database \u0026amp;\u0026amp; touch storage/app/database/database.sql Configure database .env\nDB_CONNECTION=sqlite DB_DATABASE={ABSOLUTE PATH}/storage/app/database/database.sql Create tables\nphp artisan migrate And the output should match this:\nMigration table created successfully. Migrating: 2014_10_12_000000_create_users_table Migrated: 2014_10_12_000000_create_users_table (4.11ms) Migrating: 2014_10_12_100000_create_password_resets_table Migrated: 2014_10_12_100000_create_password_resets_table (2.14ms) Migrating: 2019_08_19_000000_create_failed_jobs_table Migrated: 2019_08_19_000000_create_failed_jobs_table (2.54ms) Implementation We will be using a handful of Laravel features to demonstrate how they organically fit within the Lucid Architecture due to its timeless approach towards application structure.\nFrontend technologies used in this guide:\nTailwindCSS for styling Laravel Blade for templating Authentication We will try to avoid re-inventing the wheel as much as possible by using laravel/breeze to scaffold configuration and Auth routes, views and controllers styled with TailwindCSS.\ncomposer require laravel/breeze --dev php artisan breeze:install npm install \u0026amp;\u0026amp; npm run dev Now to watch assets and build on change we may run npm run watch.\nThe resulting files are under resources/views/auth and the welcome page has been updated to look as follows:\nTo create an account click on Register at the top right and enter your account details to be logged in to the dashboard:\nLink Submission View First, create a new route to serve our view in routes/web.php:\nRoute::get(\u0026#39;/submit\u0026#39;, function() { return view(\u0026#39;submit\u0026#39;); }); Next, we need to create the submit.blade.php template at resources/views/submit.blade.php with the following boilerplate to submit a link with a title and a description:\n\u0026lt;x-app-layout\u0026gt; \u0026lt;x-slot name=\u0026#34;header\u0026#34;\u0026gt; Add Link \u0026lt;/x-slot\u0026gt; \u0026lt;div class=\u0026#34;flex items-center justify-center h-screen\u0026#34;\u0026gt; \u0026lt;form action=\u0026#34;/submit\u0026#34; method=\u0026#34;post\u0026#34; class=\u0026#34;w-full max-w-sm bg-white shadow-md rounded px-8 pt-6 pb-8\u0026#34;\u0026gt; @csrf @if ($errors-\u0026gt;any()) \u0026lt;div class=\u0026#34;bg-red-100 border border-red-400 text-red-700 px-4 py-3 mt-2 mb-2 rounded relative\u0026#34; role=\u0026#34;alert\u0026#34;\u0026gt; Please fix the following errors \u0026lt;/div\u0026gt; @endif \u0026lt;div class=\u0026#34;md:flex md:items-center mb-6\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;md:w-1/3\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;block text-gray-500 font-bold md:text-right mb-1 md:mb-0 pr-4\u0026#34; for=\u0026#34;title\u0026#34;\u0026gt; Title \u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;md:w-2/3\u0026#34;\u0026gt; \u0026lt;input id=\u0026#34;title\u0026#34; value=\u0026#34;{{ old(\u0026#39;title\u0026#39;) }}\u0026#34; name=\u0026#34;title\u0026#34; class=\u0026#34;appearance-none border-2 @error(\u0026#39;title\u0026#39;) border-red-400 @else border-gray-200 @enderror rounded w-full py-2 px-4 text-gray-700 leading-tight focus:outline-none focus:bg-white focus:border-teal-500\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; @error(\u0026#39;title\u0026#39;) \u0026lt;p class=\u0026#34;text-red-500 text-xs italic mt-2\u0026#34;\u0026gt;{{ $message }}\u0026lt;/p\u0026gt; @enderror \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;md:flex md:items-center mb-6\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;md:w-1/3\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;block text-gray-500 font-bold md:text-right mb-1 md:mb-0 pr-4\u0026#34; for=\u0026#34;url\u0026#34;\u0026gt; URL \u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;md:w-2/3\u0026#34;\u0026gt; \u0026lt;input id=\u0026#34;url\u0026#34; value=\u0026#34;{{ old(\u0026#39;url\u0026#39;) }}\u0026#34; name=\u0026#34;url\u0026#34; class=\u0026#34;appearance-none border-2 @error(\u0026#39;url\u0026#39;) border-red-400 @else border-gray-200 @enderror rounded w-full py-2 px-4 text-gray-700 leading-tight focus:outline-none focus:bg-white focus:border-teal-500\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; @error(\u0026#39;url\u0026#39;) \u0026lt;p class=\u0026#34;text-red-500 text-xs italic mt-2\u0026#34;\u0026gt;{{ $message }}\u0026lt;/p\u0026gt; @enderror \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;md:flex md:items-center mb-6\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;md:w-1/3\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;description\u0026#34; class=\u0026#34;block text-gray-500 font-bold md:text-right mb-1 md:mb-0 pr-4\u0026#34; for=\u0026#34;desription\u0026#34;\u0026gt; Description \u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;md:w-2/3\u0026#34;\u0026gt; \u0026lt;textarea id=\u0026#34;description\u0026#34; name=\u0026#34;description\u0026#34; class=\u0026#34;appearance-none border-2 @error(\u0026#39;description\u0026#39;) border-red-400 @else border-gray-200 @enderror rounded w-full py-2 px-4 text-gray-700 leading-tight focus:outline-none focus:bg-white focus:border-teal-500\u0026#34; id=\u0026#34;description\u0026#34; name=\u0026#34;description\u0026#34;\u0026gt;{{old(\u0026#39;description\u0026#39;)}}\u0026lt;/textarea\u0026gt; @error(\u0026#39;description\u0026#39;) \u0026lt;p class=\u0026#34;text-red-500 text-xs italic mt-2\u0026#34;\u0026gt;{{ $message }}\u0026lt;/p\u0026gt; @enderror \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;md:flex md:items-center\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;md:w-1/3\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;md:w-2/3\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;shadow bg-teal-500 hover:bg-teal-400 focus:shadow-outline focus:outline-none text-white font-bold py-2 px-4 rounded\u0026#34;\u0026gt; Add \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/x-app-layout\u0026gt; Controller Generate LinkController to manage our links using lucid and have it ready for serving features.\nlucid make:controller Link Controller class created successfully. Find it at app/Http/Controllers/LinkController.php Notice the automatic addition of Controller suffix, used as a naming convention to match other suffixes in the Lucid stack such as Feature, Job and Operation.\nWe will need a method to handle the form\u0026rsquo;s submission request, let\u0026rsquo;s call it add:\napp/Http/Controllers/LinkController.php\n\u0026lt;?php namespace App\\Http\\Controllers; use Lucid\\Units\\Controller; class LinkController extends Controller { public function add() { } } Feature The add method will then serve the feature that will run the jobs required to add links. Generate a feature called AddLinkFeature:\nlucid make:feature AddLink Feature class AddLinkFeature created successfully. Find it at app/Features/AddLinkFeature.php add() will now serve AddLinkFeature\napp/Http/Controllers/LinkController.php\nuse App\\Features\\AddLinkFeature; ... public function add() { return $this-\u0026gt;serve(new AddLinkFeature()); } Beginning with the step of generating a feature will cognitively set our context to what we will be working on, helping us concentrate on the task at hand.\nLet\u0026rsquo;s expose our feature with a route:\nroutes/web.php\nuse App\\Http\\Controllers\\LinkController; Route::post(\u0026#39;/submit\u0026#39;, [LinkController::class, \u0026#39;add\u0026#39;]); So far so good, now we\u0026rsquo;ll fill our feature with the steps required to add a link.\nDatabase \u0026amp; Model Before we can start accepting data we need to prepare our database with a migration to create the links table:\nphp artisan make:migration create_links_table --create=links The generated file will contain the creation schema at database/migrations/{datetime}_create_links_table.php. Let\u0026rsquo;s add the fields for our link:\npublic function up() { Schema::create(\u0026#39;links\u0026#39;, function (Blueprint $table) { $table-\u0026gt;id(); $table-\u0026gt;string(\u0026#39;title\u0026#39;); $table-\u0026gt;string(\u0026#39;url\u0026#39;)-\u0026gt;unique(); $table-\u0026gt;text(\u0026#39;description\u0026#39;); $table-\u0026gt;timestamps(); }); } Run the migration to create the table in the database:\nphp artisan migrate Then we create our Link model class at app/Data/Models/Link.php\n\u0026lt;?php namespace App\\Data\\Models; use Illuminate\\Database\\Eloquent\\Model; class Link extends Model { protected $fillable = [\u0026#39;url\u0026#39;, \u0026#39;title\u0026#39;, \u0026#39;description\u0026#39;]; } We\u0026rsquo;re all set to start building our feature!\nRequest Validation The first step of receiving input is to validate it. We will be using Form Request validation where each Request belongs in a Domain representing the entity that\u0026rsquo;s being managed, in this case it\u0026rsquo;s Link containing an AddLink Request class.\nThis will be the beginning of working with Domains in Lucid. They\u0026rsquo;re used to group Jobs and custom classes which logic is associated with certain topic according to domain-driven design.\nStarting with validation, Lucid places Request classes within their corresponding domains. Let\u0026rsquo;s generate an AddLink request:\nlucid make:request AddLink link Request class created successfully. Find it at app/Domains/Link/Requests/AddLink.php In AddLink we\u0026rsquo;ll need to update the methods authorize() and rules() to validate the request and its input:\n\u0026lt;?php namespace App\\Domains\\Link\\Requests; use Illuminate\\Support\\Facades\\Auth; use Illuminate\\Foundation\\Http\\FormRequest; class AddLink extends FormRequest { /** * Determine if the user is authorized to make this request. * * @return bool */ public function authorize() { return Auth::check(); } /** * Get the validation rules that apply to the request. * * @return array */ public function rules() { return [ \u0026#39;title\u0026#39; =\u0026gt; [\u0026#39;required\u0026#39;, \u0026#39;max:255\u0026#39;], \u0026#39;url\u0026#39; =\u0026gt; [\u0026#39;required\u0026#39;, \u0026#39;url\u0026#39;, \u0026#39;max:255\u0026#39;], \u0026#39;description\u0026#39; =\u0026gt; [\u0026#39;required\u0026#39;, \u0026#39;max:255\u0026#39;], ]; } } With our request ready, now we need AddLinkFeature to use that request class when served. We can do that by simply injecting the request class in the feature\u0026rsquo;s handle() method and every time the feature is served this validation will be applied.\n\u0026lt;?php namespace App\\Features; use Lucid\\Units\\Feature; use App\\Domains\\Link\\Requests\\AddLink; class AddLinkFeature extends Feature { public function handle(AddLink $request) { } } Now if we visit /submit and click Add wihtout passing any input it will generate errors and print their messages from validation failures.\nSave Links To save the link we\u0026rsquo;ll create a job that saves links and run it in our feature, which will be added to our Link domain at app/Domains/Link/Jobs/SaveLinkJob along with its test tests/Unit/Domains/Link/Jobs/SaveLinkJobTest.\nlucid make:job SaveLink link Notice the naming that we\u0026rsquo;ve used with this job \u0026ldquo;SaveLinkJob\u0026rdquo; in contrast with \u0026ldquo;AddLink\u0026rdquo;. It is intended for reuse whenever needed by extending its functionality futher, for example UpdateLink feature may be able to use the same job.\nSaveLinkJob should define the parameters that are required in its constructor, a.k.a the job\u0026rsquo;s signature, rather than accessing the data from the request so that we can call this job from other places in our application (e.g. from a command or a custom class) and not be restricted by the protocol, in this case HTTP request.\nWe use this technique to increase the degree of job isolation and secure the single responsibility principle.\n\u0026lt;?php namespace App\\Domains\\Link\\Jobs; use Lucid\\Units\\Job; use App\\Data\\Models\\Link; class SaveLinkJob extends Job { private $url; private $title; private $description; /** * Create a new job instance. * * @param $url * @param $title * @param $description */ public function __construct($url, $title, $description) { $this-\u0026gt;url = $url; $this-\u0026gt;title = $title; $this-\u0026gt;description = $description; } /** * Execute the job. * * @return Link */ public function handle() { $attributes = [ \u0026#39;url\u0026#39; =\u0026gt; $this-\u0026gt;url, \u0026#39;title\u0026#39; =\u0026gt; $this-\u0026gt;title, \u0026#39;description\u0026#39; =\u0026gt; $this-\u0026gt;description, ]; return tap(new Link($attributes))-\u0026gt;save(); } } The job\u0026rsquo;s signature is its constructor: __construct($url, $title, $description) telling us what\u0026rsquo;s required to run this job. This gets easier to read with PHP 7+ where we could type-hit these parameters:\npublic function __construct(string $url, string $title, string $description) And even better with PHP 8 we could use constructor property promotion and further reduce boilerplate:\npublic function __construct( private string $url, private string $title, private string $description ) {} Then we\u0026rsquo;ll run this job from the feature to save links when received:\n\u0026lt;?php namespace App\\Features; use Lucid\\Units\\Feature; use App\\Domains\\Link\\Requests\\AddLink; use App\\Domains\\Link\\Jobs\\SaveLinkJob; use App\\Domains\\Http\\Jobs\\RedirectBackJob; class AddLinkFeature extends Feature { public function handle(AddLink $request) { $this-\u0026gt;run(new SaveLinkJob( url: $request-\u0026gt;input(\u0026#39;url\u0026#39;), title: $request-\u0026gt;input(\u0026#39;title\u0026#39;), description: $request-\u0026gt;input(\u0026#39;description\u0026#39;), )); } } Parameters As Associative Arrays It is also possible to call $this-\u0026gt;run($unit, $params) in a feature, which causes the underlying dispatcher to run SaveLinkJob syncronously by calling its handle method after initializing it with the provided $params which can be passed as an associative array where the keys must match the job\u0026rsquo;s constructor parameters in naming, but not the order. So this would still work the same:\n$this-\u0026gt;run(SaveLinkJob::class, [ \u0026#39;description\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;description\u0026#39;), \u0026#39;title\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;title\u0026#39;), \u0026#39;url\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;url\u0026#39;), ]); You may call jobs (and other units) from any class by supplying Lucid\\Bus\\UnitDispatcher trait in the class which will equip the run($unit, $params) function to run jobs and operations. With this, the class in Lucid terms is now called a custom dispatcher.\nThe last step is to redirect a successful request back to the form. To do that we\u0026rsquo;ll create a RedirectBackJob which will simply call back(). Even though it might seem like an overhead, but remember that we\u0026rsquo;re setting up for scale, and as we scale, the less free-form code we have the better; instead of having plenty of back() and back()-\u0026gt;withInput() and other calls, we centralize them in a job so that in case we ever wanted to modify that functionality or add to it, the change will only need to happen in a one place.\nRedirectBackJob will reside in a new Http domain, a place for all our HTTP-related functionality that isn\u0026rsquo;t specific to a business entity of our application, fits the abstract type of domains instead of the entity type.\nlucid make:job RedirectBackJob http Job class RedirectBackJob created successfully. Find it at app/Domains/Http/Jobs/RedirectBackJob.php Our job will provide the option withInput to determine whether input should be included in the redirection. This is a simple example of how such a simple job may later provide functionality that can be shared across the application.\n\u0026lt;?php namespace App\\Domains\\Http\\Jobs; use Lucid\\Units\\Job; class RedirectBackJob extends Job { /** * @var bool */ private $withInput; /** * Create a new job instance. * * @param bool $withInput */ public function __construct($withInput = false) { $this-\u0026gt;withInput = $withInput; } /** * Execute the job. */ public function handle() { $back = back(); if ($this-\u0026gt;withInput) { $back-\u0026gt;withInput(); } return $back; } } Testing If you visit /submit fill the form it should now add the links, but to be certain about the functionality we just built it is necessary that we write some tests to ensure it continues to.\nConfigure PHPUnit First we need to configure the database to run in a memory SQLite database instance, in phpunit.xml uncomment the following lines:\n\u0026lt;server name=\u0026#34;DB_CONNECTION\u0026#34; value=\u0026#34;sqlite\u0026#34;/\u0026gt; \u0026lt;server name=\u0026#34;DB_DATABASE\u0026#34; value=\u0026#34;:memory:\u0026#34;/\u0026gt; Unit Tests Jobs in Lucid are units, and their tests are that of a unit test where we verify that all the variations of the data it might receive wouldn\u0026rsquo;t misbehave unexpectedly.\nLet\u0026rsquo;s write a test for SaveLinkJob in tests/Unit/Domains/Link/Jobs/SaveLinkJobTest which has already been created by lucid when generating the job:\nRunnig tests prior to configuring phpunit.xml as mentioned in Configure PHPUnit will wipe out the data that is currently in your database.\n\u0026lt;?php namespace Tests\\Unit\\Domains\\Link\\Jobs; use Tests\\TestCase; use App\\Data\\Models\\Link; use Faker\\Factory as Fake; use App\\Domains\\Link\\Jobs\\SaveLinkJob; use Illuminate\\Foundation\\Testing\\RefreshDatabase; class SaveLinkJobTest extends TestCase { use RefreshDatabase; public function test_save_link_job() { $f = Fake::create(); $url = $f-\u0026gt;url; $title = $f-\u0026gt;sentence; $description = $f-\u0026gt;paragraph; $job = new SaveLinkJob($url, $title, $description); $link = $job-\u0026gt;handle(); $this-\u0026gt;assertInstanceOf(Link::class, $link); $this-\u0026gt;assertEquals($url, $link-\u0026gt;url); $this-\u0026gt;assertEquals($title, $link-\u0026gt;title); $this-\u0026gt;assertEquals($description, $link-\u0026gt;description); } } For more on testing jobs visit jobs#testing.\nFeature Test The last test is the feature\u0026rsquo;s behaviour with different input variations and make sure that all responses are as expected. In principle, Lucid\u0026rsquo;s feature tests are about testing the integration between the units that the feature runs (jobs and operations).\nStarting with our test layout as a plan to what we will be examining and prepare the test class by including RefreshDatabase trait:\ntests/Feature/AddLinkFeatureTest\n\u0026lt;?php namespace Tests\\Feature; use Tests\\TestCase; use Illuminate\\Foundation\\Testing\\RefreshDatabase; class AddLinkFeatureTest extends TestCase { use RefreshDatabase; public function test_guest_cannot_submit_a_link() { $this-\u0026gt;markTestIncomplete(); } public function test_link_is_not_created_if_validation_fails() { $this-\u0026gt;markTestIncomplete(); } public function test_link_is_not_created_with_invalid_url() { $this-\u0026gt;markTestIncomplete(); } public function test_max_length_fails_when_too_long() { $this-\u0026gt;markTestIncomplete(); } public function test_max_length_succeeds_when_under_max() { $this-\u0026gt;markTestIncomplete(); } } Now we\u0026rsquo;ll just fill the tests with corresponding calls and assertions:\nWe expect a guest to not be able to submit links since in our Request class AddLink::authorize() requires authorization:\npublic function test_guest_cannot_submit_a_link() { $response = $this-\u0026gt;post(\u0026#39;/submit\u0026#39;, [ \u0026#39;title\u0026#39; =\u0026gt; \u0026#39;Example Title\u0026#39;, \u0026#39;url\u0026#39; =\u0026gt; \u0026#39;http://example.com\u0026#39;, \u0026#39;description\u0026#39; =\u0026gt; \u0026#39;Example description.\u0026#39;, ]); $response-\u0026gt;assertStatus(403); $response-\u0026gt;assertSee(\u0026#39;This action is unauthorized.\u0026#39;); } Ensure input validation is as expected:\npublic function test_link_is_not_created_if_validation_fails() { $response = $this-\u0026gt;actingAs(User::factory()-\u0026gt;create())-\u0026gt;post(\u0026#39;/submit\u0026#39;); $response-\u0026gt;assertSessionHasErrors([\u0026#39;title\u0026#39;, \u0026#39;url\u0026#39;, \u0026#39;description\u0026#39;]); } The purpose of the data provider invalidURLs here is to keep the test concise and reduce clutter:\npublic function invalidURLs() { return [ [\u0026#39;foo.com\u0026#39;], [\u0026#39;/invalid-url\u0026#39;], [\u0026#39;//invalid-url.com\u0026#39;], ]; } /** * @dataProvider invalidURLs */ public function test_link_is_not_created_with_invalid_url($case) { $response = $this-\u0026gt;actingAs(User::factory()-\u0026gt;create()) -\u0026gt;post(\u0026#39;/submit\u0026#39;, [ \u0026#39;url\u0026#39; =\u0026gt; $case, \u0026#39;title\u0026#39; =\u0026gt; \u0026#39;Example Title\u0026#39;, \u0026#39;description\u0026#39; =\u0026gt; \u0026#39;Example description\u0026#39;, ]); $response-\u0026gt;assertSessionHasErrors([\u0026#39;url\u0026#39; =\u0026gt; \u0026#39;The url must be a valid URL.\u0026#39;]); } Finally, test input strings lengths:\npublic function test_max_length_fails_when_too_long() { $title = str_repeat(\u0026#39;a\u0026#39;, 256); $description = str_repeat(\u0026#39;a\u0026#39;, 256); $url = \u0026#39;http://\u0026#39;; $url .= str_repeat(\u0026#39;a\u0026#39;, 256 - strlen($url)); $user = User::factory()-\u0026gt;create(); $response = $this-\u0026gt;actingAs($user) -\u0026gt;post(\u0026#39;/submit\u0026#39;, compact(\u0026#39;title\u0026#39;, \u0026#39;url\u0026#39;, \u0026#39;description\u0026#39;)); $response-\u0026gt;assertSessionHasErrors([ \u0026#39;url\u0026#39; =\u0026gt; \u0026#39;The url must not be greater than 255 characters.\u0026#39;, \u0026#39;title\u0026#39; =\u0026gt; \u0026#39;The title must not be greater than 255 characters.\u0026#39;, \u0026#39;description\u0026#39; =\u0026gt; \u0026#39;The description must not be greater than 255 characters.\u0026#39;, ]); } public function test_max_length_succeeds_when_under_max() { $url = \u0026#39;http://\u0026#39;; $url .= str_repeat(\u0026#39;a\u0026#39;, 255 - strlen($url)); $data = [ \u0026#39;title\u0026#39; =\u0026gt; str_repeat(\u0026#39;a\u0026#39;, 255), \u0026#39;url\u0026#39; =\u0026gt; $url, \u0026#39;description\u0026#39; =\u0026gt; str_repeat(\u0026#39;a\u0026#39;, 255), ]; $this-\u0026gt;actingAs(User::factory()-\u0026gt;create())-\u0026gt;post(\u0026#39;/submit\u0026#39;, $data); $this-\u0026gt;assertDatabaseHas(\u0026#39;links\u0026#39;, $data); } Conclusion As far as this example goes, Lucid may seem like just an overhead on top of simple one-liners or two. Pragmatically speaking, this is almost never the case; no project begins as simple remains so simple in a few weeks later and this is where this architecture\u0026rsquo;s role becomes crucial. It is just like wine - gets better with the project\u0026rsquo;s age.\nHighlights Here are a few points that are worth mentioning to showcase where the architecture came in and how it would help forward:\nWe are still using Laravel\u0026rsquo;s internals and artisan for most of the things we did. This is intended to show how Lucid preserves Laravel\u0026rsquo;s defaults and avoids replicating or replacing them; in fact it complements them by elevating their presence and fitting them within a defined structure.\nNavigating features couldn\u0026rsquo;t get any easier, by looking at the app/Features directory you\u0026rsquo;d be able to have a summary of what this application does at a glance.\nVisiting a feature\u0026rsquo;s class would also provide an overview of the steps required with the least details possible, yet details are available when wanting to dig deeper. In addition to the presence of tests that mirror these classes which makes it easy to update functionality with reduced unintentional negative impact.\nExpanding on functionality such as SaveArticleJob makes it easy to achieve a high degree of reusable code. Consider updating a link, we\u0026rsquo;d still use this job to save an existing link by supplying an optional id parameter and have the job create or update accordingly.\n"},{"uri":"https://docs.lucidarch.dev/upgrade-guide/monolith/","title":"Monolith","tags":[],"description":"","content":"Ensure that your tests are passing at the initial state of the upgrade to be able to compare with by the end that you\u0026rsquo;ve received the expected result.\nremove deprecated Lucid packages\ncomposer remove lucid-arch/laravel-foundation lucid-arch/laravel-console\nIt is expected to see failures in the post-script since there are classes that no longer exist\nadd lucidarch/lucid\ncomposer require lucidarch/lucid\nFiles Moving everything from /src to /app\nData\nDomains\nFoundation\nServices\nServices/\u0026lt;service\u0026gt;/Tests/Features → tests/Feature/Services/\u0026lt;service\u0026gt;\nServices/\u0026lt;service\u0026gt;/Tests/Operations and other unit tests → tests/Unit/Services/\u0026lt;service\u0026gt;/Operations\nMove domain tests app/Domains/\u0026lt;domain\u0026gt;/Tests → tests/Unit/Domains/\u0026lt;domain\u0026gt;\nuse the script below to do that for you, run it at the root of the project:\n#!/bin/bash BASE_DIR=$(pwd) TESTS_DIR=\u0026#34;$BASE_DIR/tests\u0026#34; mkdir $BASE_DIR/tests/Unit/Domains for d in ./app/Domains/* ; do DOMAIN=${d##*/} echo \u0026#34;moving $d/Tests --\u0026gt; $TESTS_DIR/Unit/Domains/$DOMAIN\u0026#34; mv \u0026#34;$d/Tests\u0026#34; $TESTS_DIR/Unit/Domains/$DOMAIN done mkdir $BASE_DIR/tests/Unit/Services $BASE_DIR/tests/Feature/Services for s in ./app/Services/* ; do SERVICE=${s##*/} echo \u0026#34;moving $s/Tests/Features --\u0026gt; $TESTS_DIR/Feature/Services/$SERVICE\u0026#34; mv \u0026#34;$s/Tests/Features\u0026#34; $TESTS_DIR/Feature/Services/$SERVICE echo \u0026#34;moving $s/Tests/Operations --\u0026gt; $TESTS_DIR/Unit/Services/$SERVICE/Operations\u0026#34; mv \u0026#34;$s/Tests/Operations\u0026#34; $TESTS_DIR/Unit/Services/$SERVICE/Operations done Namespaces Rename Framework namespaces in /app namespace Framework\\ → namespace App\\ use Framework\\ → use App\\ Rename Framework in /bootstrap , /app and /config Framework\\ → App\\ Rename custom namespace in /app namespace SocialSource\\ → namespace App\\ use SocialSource\\ → use App\\ app/RouteServiceProvider.php rename Framework\\ to App\\ in protected $namespace Replace unit namespaces (find \u0026amp; replace in app folder. Additionally you may want to search other folders such as tests):\nJobs\nuse Lucid\\Foundation\\Job; → use Lucid\\Units\\Job;\nOperations\nuse Lucid\\Foundation\\Operation; → use Lucid\\Units\\Operation;\nFeatures\nuse Lucid\\Foundation\\Feature; → use Lucid\\Units\\Feature;\nServices\nLucid\\Foundation\\Providers → Lucid\\Providers\nControllers\nuse Lucid\\Foundation\\Http\\Controller; → use Lucid\\Units\\Controller;\nExceptions\nLucid\\Foundation\\InvalidInputException → Lucid\\Exceptions\\InvalidInputException\nValidator\nuse Lucid\\Foundation\\Validator; → use Lucid\\Validation\\Validator;\nReplace traits namespaces\nuse Lucid\\Foundation\\ServesFeaturesTrait; → use Lucid\\Bus\\ServesFeatures; use ServesFeaturesTrait; → use ServesFeatures; Update phpunit.xml\nRemove Services and Domains testsuits Composer delete the line under autoload.psr-4: \u0026quot;Framework\\\\\u0026quot;: \u0026quot;app/\u0026quot;, reset namespace of src \u0026quot;App\\\\\u0026quot;: \u0026quot;app/\u0026quot;, The following content (besides custom ones) must be present in composer.json:\n{ \u0026#34;autoload\u0026#34;: { \u0026#34;psr-4\u0026#34;: { \u0026#34;App\\\\\u0026#34;: \u0026#34;app/\u0026#34; } }, \u0026#34;autoload-dev\u0026#34;: { \u0026#34;psr-4\u0026#34;: { \u0026#34;Tests\\\\\u0026#34;: \u0026#34;tests/\u0026#34; } } } Run composer dump-autoload to feel the waters\nThis time it should all be clear of errors. Otherwise, keep digging and replacing until it passes\nRun tests again and expect the same results as in the run before the upgrade\n"},{"uri":"https://docs.lucidarch.dev/getting-started/monolith/","title":"Monolith","tags":[],"description":"","content":" The source code for this exercise is on GitHub.\nIn this guide we\u0026rsquo;re going to build an application to share and discuss food recipes that\u0026rsquo;s made up of two sections:\nKitchen: To manage and share recipes, calculating calories and avg. price. Forum: To discuss recipes with fellow members and get in touch with the experts. The purpose of this exercise is to demonstrate Lucid Monolith - the multi-purpose, service-oriented variant of Lucid. Typically used when you wish to apply separation of concerns yet still be able to share code that is necessary for all the parts such as models and business logic.\nThe obvious use of Monolith is to contain a large feature set within a single codebase, in contrast with Microservices where we would dissect it into several codebases and have them responsible for their own part in isolation yet integrate and communicate to get a single job done. Starting with Lucid\u0026rsquo;s Monolith grants the ability to later do the transformation, making it easier to decide on the different parts that need to go into their own [micro]services, and the code would\u0026rsquo;ve already been concentrated to minimise the move on their own.\nFor Micro - the single-purpose variant, see Getting Started • Micro\nSetup Install Laravel Let\u0026rsquo;s start by creating a new Laravel project. It is best if you refer to Laravel\u0026rsquo;s installation docs and choose your preferred way of installation, but here are the common ways to do it:\n# via the installer laravel new cookery # via composer composer create-project --prefer-dist laravel/laravel cookery Install Lucid composer require lucidarch/lucid Database Configuration Now that we have our project ready with a .env file we can configure the database connection.\nFor the brevity of this example we will utilise SQLite as it requires the least steps to get going. This is surely not recommended in real apps but will make very little difference since you can change the configuration and use your favourite database without affecting the code.\nCreate database file storage/app/database/database.sql\nmkdir -p storage/app/database \u0026amp;\u0026amp; touch storage/app/database/database.sql Configure database .env\nDB_CONNECTION=sqlite DB_DATABASE={ABSOLUTE PATH}/storage/app/database/database.sql Create tables\nphp artisan migrate And the output should match this:\nMigration table created successfully. Migrating: 2014_10_12_000000_create_users_table Migrated: 2014_10_12_000000_create_users_table (4.11ms) Migrating: 2014_10_12_100000_create_password_resets_table Migrated: 2014_10_12_100000_create_password_resets_table (2.14ms) Migrating: 2019_08_19_000000_create_failed_jobs_table Migrated: 2019_08_19_000000_create_failed_jobs_table (2.54ms) Initialize Monolith Assuming that you have ./vendor/bin in your PATH the lucid binary will be available to run Lucid commands.\nWe will start with init:monolith to initialize directory structure and specify our first service to be created along.\nlucid init:monolith Kitchen Initializing Lucid Monolith for Laravel 8.15.0 Created directories: /app/Data /app/Domains /app/Services /app/Foundation /app/Policies Service Kitchen created successfully. Activate it by adding App\\Services\\Kitchen\\Providers\\KitchenServiceProvider::class to \u0026#39;providers\u0026#39; in config/app.php Let\u0026rsquo;s do as instructed and add the service\u0026rsquo;s provider to the providers array in config/app.php and this way Laravel will recognize our Kitchen service and load its files.\nNow if we run our application with php artisan serve and visit /kitchen we should be greeted by the service. By default the service\u0026rsquo;s routes are prefixed with its name. Of course, you may modify that at app/Services/Kitchen/routes which has the exact same structure as Laravel\u0026rsquo;s default /routes.\nService Directory Structure Below is the default directory structure of every service in the monolith. They look familiar because they are the same as Laravel\u0026rsquo;s default structure, intended to provide the same functionality but with a different arrangement.\nThe highlighted directories are those that are proprietary to Lucid as we will learn throughout this guide.\napp/Services/Kitchen ├── Console │ └── Commands ├── Features ├── Operations ├── Http │ ├── Controllers │ └── Middleware ├── Providers │ ├── ApiServiceProvider.php │ ├── BroadcastServiceProvider.php │ └── RouteServiceProvider.php ├── Tests │ └── Features │ └── Operations ├── database │ ├── factories │ ├── migrations │ └── seeds ├── resources │ ├── lang │ └── views └── routes ├── api.php ├── channels.php ├── console.php └── web.php The Service Provider KitchenServiceProvider is where the service tells Laravel how to locate its files such as routes, views, lang and it may be used for anything that the service may need in the future. Having this file allows us to control the loading of serivce files conditionally.\nThe service files will not be loaded by Laravel if it weren\u0026rsquo;t registered. We used the simple method of adding the provider to the app\u0026rsquo;s providers array which means that the service files will be registered in every interaction with our application. This may not always be the intented behaviour, where we would want to register services conditionally.\nFor example, if we wish to load only Kitchen service if our domain matches kitchen.example.com we would instead register the provider in app/Providers/AppServiceProvider::regsiter as such:\npublic function regsiter() { switch (Route::input(\u0026#39;subdomain\u0026#39;)) { case \u0026#39;kitchen\u0026#39;: $this-\u0026gt;register(KitchenServiceProvider::class); break; case \u0026#39;forum\u0026#39;: $this-\u0026gt;register(ForumServiceProvider::class); break; } } Given that we define our routes with a subdomain group:\napp/Services/Kitchen/routes/web.php\nRoute::group([\u0026#39;domain\u0026#39; =\u0026gt; \u0026#39;{subdomain}.cookery.local\u0026#39;], function() { // define Kitchen routes here }); Authentication We will try to avoid re-inventing the wheel as much as possible by using laravel/breeze to scaffold configuration and Auth routes, views and controllers styled with TailwindCSS.\ncomposer require laravel/breeze --dev php artisan breeze:install npm install \u0026amp;\u0026amp; npm run dev Now to watch assets and build on change we may run npm run watch.\nThe resulting files are under resources/views/auth and the welcome page has been updated to look as follows:\nTo create an account click on Register at the top right and enter your account details to be logged in to the dashboard:\nAuthentication is central to our application, the same user will be accessing both the forum and the kitchen. We\u0026rsquo;re keeping auth and User at root for the brevity of this example but ideally we\u0026rsquo;d move the User model to our Data/Models directory and adapt Auth to read it from there in config/auth.php, though this is not necessary for now.\nRecipe Submission The first feature we will work on is to receive a recipe\u0026rsquo;s details and add it to our records. Starting with the form:\nView app/Services/Kitchen/routes/web.php\nRoute::group([\u0026#39;prefix\u0026#39; =\u0026gt; \u0026#39;kitchen\u0026#39;], function() { Route::get(\u0026#39;/recipes/new\u0026#39;, function() { return view(\u0026#39;kitchen::new\u0026#39;); }); }); Next, we need to create the form at app/Services/Kitchen/resources/views/new.blade.php with the styles:\nresources/css/app.css\n@import \u0026#39;tailwindcss/base\u0026#39;; @import \u0026#39;tailwindcss/components\u0026#39;; @import \u0026#39;tailwindcss/utilities\u0026#39;; @layer components { .form-container { @apply flex items-center justify-center h-screen; } .form { @apply w-full max-w-sm bg-white shadow-md rounded px-8 pt-6 pb-8; } .form-label { @apply block text-gray-500 font-bold mb-1 pr-4; } .form-error-status-message { @apply bg-red-100 border border-red-400 text-red-700 px-4 py-3 mt-2 mb-2 rounded relative; } .form-input-row { @apply flex items-center mb-6; } .form-input-error-label { @apply text-red-500 text-xs italic mt-2; } .form-input { @apply appearance-none border-2 rounded w-full py-2 px-4 text-gray-700 leading-tight border-gray-200; } .form-input:focus { @apply bg-white border-teal-500 outline-none; } .btn { @apply shadow bg-teal-500 text-white font-bold py-2 px-4 rounded; } .btn:hover { @apply bg-teal-400 } .btn:focus { @apply shadow-outline outline-none; } } It is recommended to scope styles per service as well, but it would\u0026rsquo;ve required a couple more steps that we\u0026rsquo;d rather skip for being out of the scope of this guide. i.e. loading a custom CSS file from app/Services/Kitchen/resources/css/kitchen.css\napp/Services/Kitchen/resources/views/new.blade.php\n\u0026lt;x-app-layout\u0026gt; \u0026lt;x-slot name=\u0026#34;header\u0026#34;\u0026gt; Add Recipe \u0026lt;/x-slot\u0026gt; \u0026lt;div class=\u0026#34;form-container\u0026#34;\u0026gt; \u0026lt;form action=\u0026#34;/submit\u0026#34; method=\u0026#34;post\u0026#34; class=\u0026#34;form\u0026#34;\u0026gt; @csrf @if ($errors-\u0026gt;any()) \u0026lt;div class=\u0026#34;form-error-status-message\u0026#34; role=\u0026#34;alert\u0026#34;\u0026gt; Please fix the following errors \u0026lt;/div\u0026gt; @endif \u0026lt;div class=\u0026#34;form-input-row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;md:w-1/3\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;form-label\u0026#34; for=\u0026#34;title\u0026#34;\u0026gt; Title \u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;md:w-2/3\u0026#34;\u0026gt; \u0026lt;input id=\u0026#34;title\u0026#34; type=\u0026#34;text\u0026#34; name=\u0026#34;title\u0026#34; value=\u0026#34;{{ old(\u0026#39;title\u0026#39;) }}\u0026#34; class=\u0026#34;form-input\u0026#34;\u0026gt; @error(\u0026#39;title\u0026#39;) \u0026lt;p class=\u0026#34;form-input-error-label\u0026#34;\u0026gt;{{ $message }}\u0026lt;/p\u0026gt; @enderror \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-input-row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;md:w-1/3\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;ingredients\u0026#34; class=\u0026#34;form-label\u0026#34; for=\u0026#34;desription\u0026#34;\u0026gt; Ingredients \u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;md:w-2/3\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;text-gray-500 text-xs\u0026#34;\u0026gt;each ingredient on a new line.\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;text-gray-500 text-xs\u0026#34;\u0026gt;Ingredient, mass /g, $ /g\u0026lt;/p\u0026gt; \u0026lt;textarea id=\u0026#34;ingredients\u0026#34; name=\u0026#34;ingredients\u0026#34; class=\u0026#34;form-input h-48\u0026#34; placeholder=\u0026#34;Avocado, 0.5, 0.07 Lettuce, 0.3, 0.04\u0026#34;\u0026gt;{{ old(\u0026#39;ingredients\u0026#39;) }}\u0026lt;/textarea\u0026gt; @error(\u0026#39;ingredients\u0026#39;) \u0026lt;p class=\u0026#34;form-input-error-label\u0026#34;\u0026gt;{{ $message }}\u0026lt;/p\u0026gt; @enderror \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-input-row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;md:w-1/3\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;instructions\u0026#34; class=\u0026#34;form-label\u0026#34; for=\u0026#34;desription\u0026#34;\u0026gt; Instructions \u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;md:w-2/3\u0026#34;\u0026gt; \u0026lt;textarea id=\u0026#34;instructions\u0026#34; name=\u0026#34;instructions\u0026#34; class=\u0026#34;form-input h-24\u0026#34; placeholder=\u0026#34;How to do it?\u0026#34;\u0026gt;{{ old(\u0026#39;instructions\u0026#39;) }}\u0026lt;/textarea\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;md:flex md:items-center\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;md:w-1/3\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;md:w-2/3\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;btn\u0026#34;\u0026gt; Add \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/x-app-layout\u0026gt; It\u0026rsquo;s a simple form:\nController Generate RecipeController in Kitchen service to handle recipe requests and serve corresponding features:\nlucid make:controller recipe kitchen Controller class created successfully. Find it at app/Services/Kitchen/Http/Controllers/RecipeController.php Notice the automatic addition of Controller suffix, used as a naming convention to match other suffixes in the Lucid stack such as Feature, Job and Operation.\nWe will need a method to handle the form\u0026rsquo;s submission request, let\u0026rsquo;s call it add:\napp/Services/Kitchen/Http/Controllers/RecipeController.php\n\u0026lt;?php namespace App\\Services\\Kitchen\\Http\\Controllers; use Lucid\\Units\\Controller; class RecipeController extends Controller { public function add() { } } Feature The add method will then serve the feature that will run the jobs and operations required to add recipes. Generate a feature called AddRecipeFeature in Kitchen service:\nlucid make:feature AddRecipe kitchen Feature class AddRecipeFeature created successfully. Find it at app/Services/Kitchen/Features/AddRecipeFeature.php add() will now serve AddRecipeFeature\napp/Services/Kitchen/Http/Controllers/RecipeController.php\nuse App\\Services\\Kitchen\\Features\\AddRecipeFeature; ... public function add() { return $this-\u0026gt;serve(new AddRecipeFeature()); } Beginning with the step of generating a feature will cognitively set our context to what we will be working on, helping us concentrate on the task at hand.\nLet\u0026rsquo;s expose our feature with a route:\nuse App\\Services\\Kitchen\\Http\\Controllers\\RecipeController; Route::group([\u0026#39;prefix\u0026#39; =\u0026gt; \u0026#39;kitchen\u0026#39;], function() { Route::post(\u0026#39;/recipes\u0026#39;, [RecipeController::class, \u0026#39;add\u0026#39;]); }); Database Before we can start accepting data we need to prepare our database with a migration to create the recipes table:\nWe would like our kitchen tables to be managed by the Kitchen service, so we will place the migrations in app/Services/Kitchen/database/migraitons instead of the default database/migrations. This is an optional step and may not fit all cases, but the option is here when needed using the lucid make:migration:\nlucid make:migration create_recipes_table kitchen Created Migration: 2020_11_18_211503_create_recipes_table Find it at app/Services/Kitchen/database/migrations Now we update the table\u0026rsquo;s schema at app/Services/Kitchen/database/migrations/{datetime}_create_recipes_table.php to include recipe fields and a reference to the user:\nSchema::create(\u0026#39;recipes\u0026#39;, function (Blueprint $table) { $table-\u0026gt;id(); $table-\u0026gt;string(\u0026#39;title\u0026#39;); $table-\u0026gt;text(\u0026#39;ingredients\u0026#39;); $table-\u0026gt;text(\u0026#39;instructions\u0026#39;)-\u0026gt;nullable(); $table-\u0026gt;decimal(\u0026#39;price\u0026#39;, 8, 3); $table-\u0026gt;unsignedBigInteger(\u0026#39;user_id\u0026#39;); $table-\u0026gt;timestamps(); $table-\u0026gt;foreign(\u0026#39;user_id\u0026#39;) -\u0026gt;references(\u0026#39;id\u0026#39;) -\u0026gt;on(\u0026#39;users\u0026#39;); }); The migration will automatically be registered so the next time we run php artisan migrate recipes table will be created:\nphp artisan migrate Migrating: 2020_11_18_211503_create_recipes_table Migrated: 2020_11_18_211503_create_recipes_table (5.43ms) Model The Data Directory app/Data\nFor a scalable set of interconnected data elements, with Lucid we place them in app/Data, because most likely over time writing the application there could develop a need for more than Models in data, such as Repositories, Value Objects, Collections and more\u0026hellip; which all fit in a central directory to consolidate them.\nCreate the Recipe model class at app/Data/Models/Recipe.php with the fields in $fillable for mass assignment:\n\u0026lt;?php namespace App\\Data\\Models; use Illuminate\\Database\\Eloquent\\Model; class Recipe extends Model { protected $fillable = [\u0026#39;title\u0026#39;, \u0026#39;ingredients\u0026#39;, \u0026#39;instructions\u0026#39;, \u0026#39;price\u0026#39;, \u0026#39;user_id\u0026#39;]; } Request Validation The first step of receiving input is to validate it. We will be using Form Request validation where each Request belongs in a Domain representing the entity that\u0026rsquo;s being managed, in this case it\u0026rsquo;s Recipe containing an AddRecipe Request class.\nThis will be the beginning of working with Domains in Lucid. They\u0026rsquo;re used to group Jobs and custom classes which logic is associated with certain topic according to domain-driven design.\nStarting with validation, Lucid places Request classes within their corresponding domains. Let\u0026rsquo;s generate an AddRecipe request:\nAbout the naming of the request class, it also would be an option to name it CreateRecipe instead of AddRecipe to fulfill the CRUD convention, but AddRecipe was easier to read and pronounce in this particular case.\nlucid make:request AddRecipe recipe Request class created successfully. Find it at app/Domains/Recipe/Requests/AddRecipe.php In AddRecipe we\u0026rsquo;ll need to update the methods authorize() and rules() to validate the request and its input. Validation rules are the essentials:\n\u0026lt;?php namespace App\\Domains\\Recipe\\Requests; use Illuminate\\Support\\Facades\\Auth; use Illuminate\\Foundation\\Http\\FormRequest; class AddRecipe extends FormRequest { /** * Determine if the user is authorized to make this request. * * @return bool */ public function authorize() { return Auth::check(); } /** * Get the validation rules that apply to the request. * * @return array */ public function rules() { return [ \u0026#39;title\u0026#39; =\u0026gt; [\u0026#39;required\u0026#39;, \u0026#39;max:255\u0026#39;], \u0026#39;ingredients\u0026#39; =\u0026gt; [\u0026#39;required\u0026#39;, \u0026#39;max:255\u0026#39;], \u0026#39;instructions\u0026#39; =\u0026gt; [\u0026#39;max:255\u0026#39;], ]; } } With our request ready, now we need AddRecipeFeature to use that request class when served. We can do that by simply injecting the request class in the feature\u0026rsquo;s handle() method and every time the feature is served this validation will be applied.\n\u0026lt;?php namespace App\\Services\\Kitchen\\Features; use Lucid\\Units\\Feature; use App\\Domains\\Recipe\\Requests\\AddRecipe; class AddRecipeFeature extends Feature { public function handle(AddRecipe $request) { } } Now if we visit /submit and click Add wihtout passing any input it will generate errors and print their messages from validation failures.\nCalculate Recipe Price To calculate the recipe price we need to do the following:\nParse the ingredients into an associative array with: name, quantity and price Get each ingredient\u0026rsquo;s usage price: quantity x price Sum all ingredient usage prices to get recipe price ∑ ingredient price Value Objects Looking at this requirement it seems that each step fits within a job, but thinking a little longer spawns the idea of Value Objects into thought. Especially that there will be data exchange between several jobs.\nThe prominent idea would be to have an Ingredient object that\u0026rsquo;s passed around instead of a primitive data type - associative array. It will make it easier for someone reading the code to tell the structure (fields) by referring to the class rather than having to guess and run after associative array key assignment instructions to figure out the final structure.\nIn other words, let\u0026rsquo;s represent our Ingredient as a Value Object! Unlike models, value objects are only to be used at run time and never stored.\nThis concept is NOT related to the Lucid architecture although endorsed for scale. For more on value objects, Martin Fowler put it best in ValueObject in the domain-driven design section.\nThis brings up another advantage for the app/Data directory which will hold our value objects in app/Data/Values next to app/Data/Models.\nCreate Ingredient value object at app/Data/Values/Ingredient.php and we make it optional to have quantity and price\n\u0026lt;?php namespace App\\Data\\Values; class Ingredient { public string $name; public float $quantity; public float $price; public function __construct(string $name, float $quantity = 0, float $price = 0) { $this-\u0026gt;name = $name; $this-\u0026gt;quantity = $quantity; $this-\u0026gt;price = $price; } } Step 1: Parse Ingredients Now we create a job that receives the Recipe model and parses ingredient field into Ingredent instances, calling it ParseIngredientsJob.\nSince we will be dealing with several instances, Collection classes are a powerful superset to array and it woule be perfect to extend and make it easier for the receiver of the results to use and extract value from.\nLet\u0026rsquo;s create a specific collection for ingredients to pass around in app/Data/Collections/IngredientsCollection.php\n\u0026lt;?php namespace App\\Data\\Collections; use Illuminate\\Support\\Collection; /** * A collection of Ingredient instances. */ class IngredientsCollection extends Collection { } Now we can type-hint for it and visually represent what we\u0026rsquo;re expecting in this collection.\nNext is ParseIngredientsJob that will have the logic for this transformation from a string of ingredients to IngredientsCollection containing Ingredient value object instances.\nlucid make:job ParseIngredientsJob recipe Job class ParseIngredientsJob created successfully. Find it at app/Domains/Recipe/Jobs/ParseIngredientsJob.php \u0026lt;?php namespace App\\Domains\\Recipe\\Jobs; use Lucid\\Units\\Job; use App\\Data\\Models\\Recipe; use App\\Data\\Values\\Ingredient; use App\\Data\\Collections\\IngredientsCollection; class ParseIngredientsJob extends Job { private string $ingredients; /** * Create a new job instance. * * @param string $ingredients */ public function __construct(string $ingredients) { $this-\u0026gt;ingredients = $ingredients; } /** * Execute the job. * * @return IngredientsCollection */ public function handle(): IngredientsCollection { $ingredients = new IngredientsCollection(); foreach (array_filter(explode(\u0026#34;\\r\\n\u0026#34;, $this-\u0026gt;ingredients)) as $line) { $ingredient = new Ingredient(...explode(\u0026#39;,\u0026#39;, $line)); $ingredients-\u0026gt;push($ingredient); } return $ingredients; } } We have oursleves a job that can be called anywhere we receive a string of ingredients and would like to parse it.\nA bit about the code above:\narray_filter(explode(\u0026quot;\\r\\n\u0026quot;, $this-\u0026gt;ingredients)) turns new lines into array elements and removes empty ones new Ingredient(...explode(',', $line)) creates a new Ingredients instance by turning comma separated string into parameters The returned result from that job would look like this:\nApp\\Data\\Collections\\IngredientsCollection { items: [ 0 =\u0026gt; App\\Data\\Values\\Ingredient { name: \u0026#34;Avocado\u0026#34; quantity: 0.5 price: 0.07 total: 0.035 } 1 =\u0026gt; App\\Data\\Values\\Ingredient { name: \u0026#34;Lettuce\u0026#34; quantity: 0.3 price: 0.04 total: 0.012 } ] Step 2: Calculate Ingredient\u0026rsquo;s Total Price To calculate an ingredient\u0026rsquo;s own total price we simply do $quantity * $price but the question is where should this code be?\nThe thinking process to figure that out starts with the question \u0026ldquo;where would the next person look for this?\u0026rdquo; and the best answer to it wins. In this case, to know the price of an ingredient, it is obvious that the first place to look is the Ingredient value object. Becuase if we were to put it somewhere else outside the class, the next time we visit Ingredient we\u0026rsquo;d see that it recieves the total price as an argument in its constructor but then we\u0026rsquo;d have to search for the place where this is being set. Besides having an hidden dependency between classes.\nLet\u0026rsquo;s update Ingredient class to calculate its own total:\n\u0026lt;?php namespace App\\Data\\Values; class Ingredient { public string $name; public float $quantity; public float $price; public float $total; public function __construct(string $name, float $quantity = 0, float $price = 0) { $this-\u0026gt;name = $name; $this-\u0026gt;quantity = $quantity; $this-\u0026gt;price = $price; $this-\u0026gt;total = $this-\u0026gt;calculateTotal(); } public function calculateTotal() { return $this-\u0026gt;quantity * $this-\u0026gt;price; } } Step 3: Calculate Recipe Total Price Let\u0026rsquo;s create a job to calculate the total price from IngredientsCollection calling it CalculateIngredientsTotalJob and returns a single float value.\nlucid make:job CalculateIngredientsTotalJob recipe Job class CalculateIngredientsTotalJob created successfully. Find it at app/Domains/Recipe/Jobs/CalculateIngredientsTotalJob.php \u0026lt;?php namespace App\\Domains\\Recipe\\Jobs; use Lucid\\Units\\Job; use App\\Data\\Collections\\IngredientsCollection; class CalculateIngredientsTotalJob extends Job { private IngredientsCollection $ingredients; /** * Create a new job instance. * * @param IngredientsCollection $ingredients */ public function __construct(IngredientsCollection $ingredients) { $this-\u0026gt;ingredients = $ingredients; } /** * Execute the job. * * @return float */ public function handle(): float { return $this-\u0026gt;ingredients-\u0026gt;sum(\u0026#39;total\u0026#39;); } } Run The Jobs Now in AddRecipeFeature we run the jobs:\npublic function handle(AddRecipe $request) { $ingredients = $this-\u0026gt;run(new ParseIngredientsJob( ingredients: $request-\u0026gt;input(\u0026#39;ingredients\u0026#39;), )); $price = $this-\u0026gt;run(new CalculateIngredientsTotalJob($ingredients)); } Final Step: Group Jobs In Operations It is indispensable for ParseIngredientsJob and CalculateIngredientsTotalJob to run together every time we need to calculate a recipe\u0026rsquo;s price. This case spawns Operations into thought, to group these steps in one operation that we can simply run with Lucid $this-\u0026gt;run(new CalculateRecipePriceOperation($ingredient)) which runs jobs performing both steps above. Moreover, we would still be able to run any of the jobs separatly in different conditions if needed.\nlucid make:operation CalculateRecipePrice kitchen Operation class CalculateRecipePriceOperation created successfully. Find it at app/Services/Kitchen/Operations/CalculateRecipePriceOperation.php \u0026lt;?php namespace App\\Services\\Kitchen\\Operations; use Lucid\\Units\\Operation; use App\\Data\\Collections\\IngredientsCollection; use App\\Domains\\Recipe\\Jobs\\ParseIngredientsJob; use App\\Domains\\Recipe\\Jobs\\CalculateIngredientsTotalJob; class CalculateRecipePriceOperation extends Operation { private string $ingredients; public function __construct(string $ingredients) { $this-\u0026gt;ingredients = $ingredients; } public function handle(): float { $ingredients = $this-\u0026gt;run(new ParseIngredientsJob( ingredients: $this-\u0026gt;ingredients, )); return $this-\u0026gt;run(new CalculateIngredientsTotalJob($ingredients)); } } Then in the feature we\u0026rsquo;d replace the two jobs with just one call:\npublic function handle(AddRecipe $request) { $price = $this-\u0026gt;run(new CalculateRecipePriceOperation( ingredients: $request-\u0026gt;input(\u0026#39;ingredients\u0026#39;), )); } Save Recipes To save the recipe we\u0026rsquo;ll create a job that saves recipes and run it in our feature, which will be added to our Recipe domain at app/Domains/Recipe/Jobs/SaveRecipeJob along with its test tests/Unit/Domains/Recipes/Jobs/SaveRecipeJobTest.\nlucid make:job SaveRecipe recipe Job class SaveRecipeJob created successfully. Find it at app/Domains/Recipe/Jobs/SaveRecipeJob.php Notice the naming that we\u0026rsquo;ve used with this job \u0026ldquo;SaveRecipeJob\u0026rdquo; in contrast with \u0026ldquo;AddRecipe\u0026rdquo;. It is intended for reuse whenever needed by extending its functionality futher, for example UpdateRecipe feature may be able to use the same job.\nSaveRecipeJob should define the parameters that are required in its constructor, a.k.a the job\u0026rsquo;s signature, rather than accessing the data from the request so that we can call this job from other places in our application (e.g. from a command or a custom class) and not be restricted by the protocol, in this case HTTP request.\nWe use this technique to increase the degree of job isolation and secure the single responsibility principle.\n\u0026lt;?php namespace App\\Domains\\Recipe\\Jobs; use Lucid\\Units\\Job; use App\\Models\\User; use App\\Data\\Models\\Recipe; class SaveRecipeJob extends Job { private string $title; private string $ingredients; private string $instructions; private string $price; private User $user; /** * Create a new job instance. * * @param $title * @param $ingredients * @param $instructions * @param $price * @param User $user */ public function __construct($title, $ingredients, $instructions, $price, User $user) { $this-\u0026gt;title = $title; $this-\u0026gt;ingredients = $ingredients; $this-\u0026gt;instructions = $instructions; $this-\u0026gt;price = $price; $this-\u0026gt;user = $user; } /** * Execute the job. * * @return Recipe */ public function handle(): Recipe { $attributes = [ \u0026#39;title\u0026#39; =\u0026gt; $this-\u0026gt;title, \u0026#39;ingredients\u0026#39; =\u0026gt; $this-\u0026gt;ingredients, \u0026#39;instructions\u0026#39; =\u0026gt; $this-\u0026gt;instructions, \u0026#39;price\u0026#39; =\u0026gt; $this-\u0026gt;price, \u0026#39;user_id\u0026#39; =\u0026gt; $this-\u0026gt;user-\u0026gt;getKey(), ]; return tap(new Recipe($attributes))-\u0026gt;save(); } } The job\u0026rsquo;s signature is its constructor: __construct($title, $ingredients, $instructions, $price) telling us what\u0026rsquo;s required to run this job. This gets easier to read and use with PHP 7+ where we could type-hit these parameters:\npublic function __construct( string $title, string $ingredients, string $instructions, int $price) And even better with PHP 8 we could use constructor property promotion and further reduce boilerplate:\npublic function __construct( private string $title, private string $ingredients, private string $instructions, private int $price ) {} Note On Storage Approach\nWe are taking a rather untraditional approach in this example. Easy on storage by saving ingredients as plain text rather than splitting them up into their own model and building many-to-many relationships between recipes and ingredients, which may have been a better approach from a storage perspective. However, for the sake of demonstrating a more complex case where we split them up and represent them in value objects, because the relational approach is a familiar one and this example covers a wider range for variety reasons.\nThen we\u0026rsquo;ll run this job from the feature to save recipes when served:\npublic function handle(AddRecipe $request) { $price = $this-\u0026gt;run(new CalculateRecipePriceOperation( ingredients: $request-\u0026gt;input(\u0026#39;ingredients\u0026#39;), )); $this-\u0026gt;run(new SaveRecipeJob( title: $request-\u0026gt;input(\u0026#39;title\u0026#39;), ingredients: $request-\u0026gt;input(\u0026#39;ingredients\u0026#39;), instructions: $request-\u0026gt;input(\u0026#39;instructions\u0026#39;), price: $price, user: Auth::user(), )); } Calling $this-\u0026gt;run($unit, $params) in a feature triggers the underlying dispatcher to run SaveRecipeJob instantly and syncronously by calling its handle method after initializing it with the provided $params which are passed as an associative array where the keys must match the job\u0026rsquo;s constructor parameters in naming, but not the order. So this would still work the same:\n$this-\u0026gt;run(new SaveRecipeJob( instructions: $request-\u0026gt;input(\u0026#39;instructions\u0026#39;), ingredients: $request-\u0026gt;input(\u0026#39;ingredients\u0026#39;), price: $price, title: $request-\u0026gt;input(\u0026#39;title\u0026#39;), )); You may call jobs (and other units) from any class by supplying Lucid\\Bus\\UnitDispatcher trait in the class which will equip the run($unit, $params) function to run jobs and operations. With this, the class in Lucid terms is now called a custom dispatcher.\nThe last step is to redirect a successful request back to the form. To do that we\u0026rsquo;ll create a RedirectBackJob which will simply call back(). Even though it might seem like an overhead, but remember that we\u0026rsquo;re setting up for scale, and as we scale, the less free-form code we have the better; instead of having plenty of back() and back()-\u0026gt;withInput() and other calls, we centralize them in a job so that in case we ever wanted to modify that functionality or add to it, the change will only need to happen in a one place.\nRedirectBackJob will reside in a new Http domain, a place for all our HTTP-related functionality that isn\u0026rsquo;t specific to a business entity of our application, fits the abstract type of domains instead of the entity type.\nlucid make:job RedirectBackJob http Job class RedirectBackJob created successfully. Find it at app/Domains/Http/Jobs/RedirectBackJob.php Our job will provide the option withInput to determine whether input should be included in the redirection. This is a simple example of how such a simple job may later provide functionality that can be shared across the application.\n\u0026lt;?php namespace App\\Domains\\Http\\Jobs; use Lucid\\Units\\Job; class RedirectBackJob extends Job { /** * @var bool */ private $withInput; /** * Create a new job instance. * * @param bool $withInput */ public function __construct($withInput = false) { $this-\u0026gt;withInput = $withInput; } /** * Execute the job. */ public function handle() { $back = back(); if ($this-\u0026gt;withInput) { $back-\u0026gt;withInput(); } return $back; } } Finally, conclude the feature by responding:\npublic function handle(AddRecipe $request) { $price = $this-\u0026gt;run(new CalculateRecipePriceOperation( ingredients: $request-\u0026gt;input(\u0026#39;ingredients\u0026#39;), ]); $this-\u0026gt;run(new SaveRecipeJob( user: Auth::user(), price: $price, title: $request-\u0026gt;input(\u0026#39;title\u0026#39;), ingredients: $request-\u0026gt;input(\u0026#39;ingredients\u0026#39;), instructions: $request-\u0026gt;input(\u0026#39;instructions\u0026#39;), ]); return $this-\u0026gt;run(new RedirectBackJob()); } Testing If you visit /kitchen/recipes/new and fill the form it should now add the recipes, but to be certain about the functionality we just built it is necessary that we write some tests to ensure it continues to.\nConfigure PHPUnit First we need to configure the database to run in a memory SQLite database instance, in phpunit.xml uncomment the following lines:\n\u0026lt;server name=\u0026#34;DB_CONNECTION\u0026#34; value=\u0026#34;sqlite\u0026#34;/\u0026gt; \u0026lt;server name=\u0026#34;DB_DATABASE\u0026#34; value=\u0026#34;:memory:\u0026#34;/\u0026gt; Unit Tests Jobs in Lucid are units, and their tests are that of a unit test where we verify that all the variations of the data it might receive wouldn\u0026rsquo;t misbehave unexpectedly.\nRunnig tests prior to configuring phpunit.xml as mentioned in Configure PHPUnit will wipe out the data that is currently in your database.\nParseIngredientsJobTest Let\u0026rsquo;s write a test for ParseIngredientsJob to make sure that it\u0026rsquo;s failsafe, in tests/Unit/Domains/Recipe/Jobs/ParseIngredientsJobTest which has already been created by lucid when generating the job. The test should cover three conditions:\nsuccessful parsing parsing empty string of ingredients failsafe parsing with missing values \u0026lt;?php namespace Tests\\Unit\\Domains\\Recipe\\Jobs; use Tests\\TestCase; use App\\Data\\Collections\\IngredientsCollection; use App\\Domains\\Recipe\\Jobs\\ParseIngredientsJob; class ParseIngredientsJobTest extends TestCase { public function test_parse_ingredients_job() { $input = \u0026#34;Avocado, 1, 1.2\\r\\nLettuce, 0.4, 0.8\u0026#34;; $job = new ParseIngredientsJob($input); $ingredients = $job-\u0026gt;handle(); $this-\u0026gt;assertInstanceOf(IngredientsCollection::class, $ingredients); $this-\u0026gt;assertEquals(\u0026#39;Avocado\u0026#39;, $ingredients[0]-\u0026gt;name); $this-\u0026gt;assertEquals(1.0, $ingredients[0]-\u0026gt;quantity); $this-\u0026gt;assertEquals(1.2, $ingredients[0]-\u0026gt;price); $this-\u0026gt;assertEquals(1.2, $ingredients[0]-\u0026gt;total); $this-\u0026gt;assertEquals(\u0026#39;Lettuce\u0026#39;, $ingredients[1]-\u0026gt;name); $this-\u0026gt;assertEquals(0.4, $ingredients[1]-\u0026gt;quantity); $this-\u0026gt;assertEquals(0.8, $ingredients[1]-\u0026gt;price); $this-\u0026gt;assertEquals(0.32, $ingredients[1]-\u0026gt;total); } public function test_parsing_empty_ingredients() { $job = new ParseIngredientsJob(\u0026#34;\u0026#34;); $ingredients = $job-\u0026gt;handle(); $this-\u0026gt;assertInstanceOf(IngredientsCollection::class, $ingredients); $this-\u0026gt;assertTrue($ingredients-\u0026gt;isEmpty()); } public function test_failsafe_parsing_ingredients_with_missing_values() { $input = \u0026#34;Missing Price, 1\\r\\nOnly Title\\r\\n\u0026#34;; $job = new ParseIngredientsJob($input); $ingredients = $job-\u0026gt;handle(); $this-\u0026gt;assertInstanceOf(IngredientsCollection::class, $ingredients); $this-\u0026gt;assertEquals(2, $ingredients-\u0026gt;count()); $this-\u0026gt;assertEquals(\u0026#39;Missing Price\u0026#39;, $ingredients[0]-\u0026gt;name); $this-\u0026gt;assertEquals(1.0, $ingredients[0]-\u0026gt;quantity); $this-\u0026gt;assertEquals(0, $ingredients[0]-\u0026gt;price); $this-\u0026gt;assertEquals(0, $ingredients[0]-\u0026gt;total); $this-\u0026gt;assertEquals(\u0026#39;Only Title\u0026#39;, $ingredients[1]-\u0026gt;name); $this-\u0026gt;assertEquals(0, $ingredients[1]-\u0026gt;quantity); $this-\u0026gt;assertEquals(0, $ingredients[1]-\u0026gt;price); $this-\u0026gt;assertEquals(0, $ingredients[1]-\u0026gt;total); } } There is only one case where parsing fails with this implementation: (i.e. Avocado, ,2.5) it is when skipping values. Consider it an exercise to improve the code! It was left out in this example to not complicate logic further.\nFor more on testing jobs visit jobs#testing.\nThe tests for the rest of the jobs are available in the source code.\nCalculateRecipeOperationTest Testing operations is fairly similar and also fits among unit testing. We\u0026rsquo;ll right the tests in the generated file tests/Unit/Services/Kitchen/Operations/CalculateRecipeOperationTest\n\u0026lt;?php namespace Tests\\Unit\\Services\\Kitchen\\Operations; use Tests\\TestCase; use App\\Services\\Kitchen\\Operations\\CalculateRecipePriceOperation; class CalculateRecipeOperationTest extends TestCase { public function test_calculate_recipe_operation() { $input = \u0026#34;Avocado, 1, 1.2\\r\\nLettuce, 0.4, 0.8\u0026#34;; $op = new CalculateRecipePriceOperation($input); $this-\u0026gt;assertEquals(1.52, $op-\u0026gt;handle()); } public function test_calculating_empty_recipe_operation() { $op = new CalculateRecipePriceOperation(\u0026#34;\u0026#34;); $this-\u0026gt;assertEquals(0.0, $op-\u0026gt;handle()); } public function test_calculating_recipe_with_missing_values_operation() { $input = \u0026#34;Missing Price, 1\\r\\nOnly Title\\r\\n\u0026#34;; $op = new CalculateRecipePriceOperation($input); $this-\u0026gt;assertEquals(0.0, $op-\u0026gt;handle()); } } For more on testing operations visit operations#testing\nFeature Test The last test if the feature\u0026rsquo;s behaviour with different input variations and make sure that all responses are as expected. In principle, Lucid\u0026rsquo;s feature tests are about testing the integration between the units that the feature runs (jobs and operations).\nStarting with our test layout as a plan to what we will be examining and prepare the test class by including RefreshDatabase trait:\ntests/Feature/Services/Kitchen/AddRecipeFeatureTest.php\n\u0026lt;?php namespace Tests\\Feature\\Services\\Kitchen; use Tests\\TestCase; use Illuminate\\Foundation\\Testing\\RefreshDatabase; class AddRecipeFeatureTest extends TestCase { use RefreshDatabase; public function test_guest_cannot_submit_a_recipe() { $this-\u0026gt;markTestIncomplete(); } public function test_recipe_is_not_created_if_validation_fails() { $this-\u0026gt;markTestIncomplete(); } public function test_max_length_fails_when_too_long() { $this-\u0026gt;markTestIncomplete(); } public function test_max_length_succeeds_when_under_max() { $this-\u0026gt;markTestIncomplete(); } } Now we\u0026rsquo;ll just fill the tests with corresponding calls and assertions:\nWe expect a guest to not be able to submit recipes since in our Request class AddRecipe::authorize() requires authorization:\npublic function test_guest_cannot_submit_a_recipe() { $response = $this-\u0026gt;post(\u0026#39;/kitchen/recipes\u0026#39;, [ \u0026#39;title\u0026#39; =\u0026gt; \u0026#39;Avocado Salad Starter\u0026#39;, \u0026#39;ingredients\u0026#39; =\u0026gt; \u0026#34;Avocado, 1, 1.2\\r\\nLettuce, 0.4, 0.8\u0026#34;, \u0026#39;instructions\u0026#39; =\u0026gt; \u0026#39;Mix it with oil and enjoy!\u0026#39;, ]); $response-\u0026gt;assertStatus(403); $response-\u0026gt;assertSee(\u0026#39;This action is unauthorized.\u0026#39;); } Ensure input validation is as expected:\npublic function test_recipe_is_not_created_if_validation_fails() { $response = $this-\u0026gt;actingAs(User::factory()-\u0026gt;create())-\u0026gt;post(\u0026#39;/kitchen/recipes\u0026#39;); $response-\u0026gt;assertSessionHasErrors([\u0026#39;title\u0026#39;, \u0026#39;ingredients\u0026#39;]); } Finally, test input strings lengths:\npublic function test_max_length_fails_when_too_long() { $title = str_repeat(\u0026#39;a\u0026#39;, 256); $ingredients = str_repeat(\u0026#39;a\u0026#39;, 256); $instructions = str_repeat(\u0026#39;a\u0026#39;, 256); $user = User::factory()-\u0026gt;create(); $response = $this-\u0026gt;actingAs($user) -\u0026gt;post(\u0026#39;/kitchen/recipes\u0026#39;, compact(\u0026#39;title\u0026#39;, \u0026#39;ingredients\u0026#39;, \u0026#39;instructions\u0026#39;)); $response-\u0026gt;assertSessionHasErrors([ \u0026#39;title\u0026#39; =\u0026gt; \u0026#39;The title may not be greater than 255 characters.\u0026#39;, \u0026#39;ingredients\u0026#39; =\u0026gt; \u0026#39;The ingredients may not be greater than 255 characters.\u0026#39;, \u0026#39;instructions\u0026#39; =\u0026gt; \u0026#39;The instructions may not be greater than 255 characters.\u0026#39;, ]); } public function test_max_length_succeeds_when_under_max() { $data = [ \u0026#39;title\u0026#39; =\u0026gt; str_repeat(\u0026#39;a\u0026#39;, 255), \u0026#39;ingredients\u0026#39; =\u0026gt; str_repeat(\u0026#39;a\u0026#39;, 255), \u0026#39;instructions\u0026#39; =\u0026gt; str_repeat(\u0026#39;a\u0026#39;, 255), ]; $this-\u0026gt;actingAs(User::factory()-\u0026gt;create())-\u0026gt;post(\u0026#39;/kitchen/recipes\u0026#39;, $data); $this-\u0026gt;assertDatabaseHas(\u0026#39;recipes\u0026#39;, $data); } Conclusion We\u0026rsquo;ve covered a breadth of Lucid features with this exercise, however it only covered the Kitchen service. We are left with the Forum service, which is similar in process to Kitchen, just different business logic. For that reason we\u0026rsquo;ll leave it to you to test your familiarity with the architecture, and the full source code is present as a reference Getting Started - Monolith.\nHighlights Application logic is segregated in services that makes it extremely simple to find corresponding logic when needed.\nWe are still using Laravel\u0026rsquo;s internals and artisan for most of the things we did. This is intended to show how Lucid preserves Laravel\u0026rsquo;s defaults and avoids replicating or replacing them; in fact it complements them by elevating their presence and fitting them within a defined structure.\nNavigating services and their features couldn\u0026rsquo;t get any easier, by looking at the app/Services/*/Features directory you\u0026rsquo;d be able to have a summary of what this application does at a glance.\nVisiting a feature\u0026rsquo;s class would also provide an overview of the steps required with the least details possible, yet details are available when wanting to dig deeper. In addition to the presence of tests that mirror these classes which makes it easy to update functionality with reduced unintentional negative impact.\nExpanding on functionality such as SaveRecipeJob makes it easy to achieve a high degree of reusable code. Consider updating a recipe, we\u0026rsquo;d still use this job to save an existing recipe by supplying an optional id parameter and have the job create or update accordingly.\n"},{"uri":"https://docs.lucidarch.dev/philosophy/","title":"Philosophy","tags":[],"description":"","content":"Throughout our careers as engineers we encounter numerous similar tasks disguised in different forms, maybe having slight differences. Every time we encounter the same task, we think it through based on our previous accomplishment of the task and figure out a better way to do it according to our gained experience. In the field of science, this is the natural progression of the learning experience - trial and error. Nevertheless, many have tried before us and have passed best practices that we [as a community] adopted as principles and guidelines to become an organic extension of our workflow, intrinsically applying them with little thinking effort.\nLucid isn\u0026rsquo;t any different, it is an accumulation of experiences in building scalable products to serve various industries by interchangeable teams. Based on the many mistakes we\u0026rsquo;ve made and the suffering we dealt with every time we revisit a \u0026ldquo;legacy\u0026rdquo; project, or during the onboarding process of someone new to the team, where the training process cannot keep up with the variety of opinions that\u0026rsquo;s been implemented in different projects, regardless of whether they\u0026rsquo;re right or wrong, they are many and have no single basis, a foundation, or a single architecture.\nWe wanted something simple [KISS] yet effective at scale. Enjoyable to work with by all levels of engineers alike. And elevates the level of understanding abstraction throughout its steep learning process. Simply put:\n\u0026nbsp;\u0026nbsp;Lucid is a set of principles that depend on our discipline to preserve\u0026nbsp;\u0026nbsp; Name \u0026ldquo;Expressed clearly; easy to understand\u0026rdquo; marks the ultimate objective that the architecture intends to achieve in code.\nEmblem Foundation The more you look at it, the more different shapes you will see. Some of these shapes may seem like a building or a block and they go in different directions. However, they are all starting from the same center - The Foundation.\nResilience From it emerges lines that have equal height, though go in different directions but have similar characteristics - representing the malleability of Lucid. Though, without guidelines and principles the outcome will not be desirable. Hence the straight lines that go in one and only one direction, representing the responsibility of each component in our code regardless of its destination.\nDirection The compass was an inspiration to the logo - without it we will surely get lost. Not knowing where we are, in which direction to go and how to go there is even worse. However, if we\u0026rsquo;ve been down the same road before it will be easier to know what should happen next.\nLike a compass, Lucid provides the guidance and acts as a reliable companion to your code navigation journey.\nAlso, a compass has no final destination and is only there to lead us wherever we wish to go, similar to any project that is ever evolving but the compass will never change direction.\nClarity From darkness to light. The dark end of the logo represents the chaos that our projects end up having after a long period of work and re-work, the variety of features they contain along with their changes. Going through the foundation (the center) - in this case Lucid - our projects go out of the other side in light - clear, understandable and easy to work with.\n"},{"uri":"https://docs.lucidarch.dev/principles/","title":"Principles","tags":[],"description":"","content":" Features shall serve a single purpose Favour creating as many of them as you wish rather than complicating a single one.\nJobs shall perform a single task No job should do two things at a time, it will only get confusing the more you do it.\nDomains shouldn\u0026rsquo;t cross When working within a domain, strive to preserve the boundaries by not using functionality from other domains. If you encounter a case where you should, consider Foundation, Operations and Features by rethinking your design.\nFeatures shall not call other features Run as many jobs and operations as you like, but never a feature.\nJobs shall not call other jobs This is your business logic, keep it concise by avoiding nesting hell.\nOperations shall not call other operations Run as many jobs as you like, but never any other unit.\nControllers serve Features Consistency is key for a successful architecture, and so are thin controllers to a successful MVC application.\nWrite code that humans can read Machines will run it nonetheless, it is us who will suffer.\n"},{"uri":"https://docs.lucidarch.dev/installation/","title":"Installation","tags":[],"description":"","content":"Install Laravel The Lucid Architecture is delivered as a Composer package lucidarch/lucid. Its only requirement is a Laravel project so to begin the installation, first grab a Laravel instance by simply running\ncomposer create-project --prefer-dist laravel/laravel blog Or head over to Laravel\u0026rsquo;s Installation docs for other means of installation.\nInstall Lucid composer require lucidarch/lucid Make sure to place Composer\u0026rsquo;s project vendor bin direcotry in your $PATH so the lucid executable can be located by your system. Usually it\u0026rsquo;s done by running export PATH=\u0026quot;$PATH:./vendor/bin\u0026quot; to have it available in your current Terminal session, or add it to your corresponding Terminal profile (e.g. ~/.bashrc, ~/.bash_profile, ~/.zshrc) to have it permanently loaded with every session.\nVersions \u0026amp; Compatibility Lucid\u0026rsquo;s versioning system follows the semantic versioning scheme. The latest Lucid version is tested against the following matrix, hence providing support to any combination of them:\nLaravel 8 7 6 5.5 (LTS)\nPHP: 8.0 7.4 7.3 7.2 7.1 7.0.21\nInitialization Lucid structure initialization is an optional step. If you\u0026rsquo;ve required the package you may already begin using lucid executable to generate units such as Jobs, Features and Operations.\nHowever, if you\u0026rsquo;ve familiarized yourself with the predefined variants of Lucid - Micro and Monolith - you may wish to initialize your application.\nMicro Initialize a Micro instance:\nlucid init:micro This will generate an initial Micro structure:\napp ├── Console │ └── Kernel.php ├── Data └── Models ├── Domains ├── Features ├── Operations ├── Exceptions │ └── Handler.php ├── Http │ ├── Controllers │ ├── Kernel.php │ └── Middleware ├── Policies └── Providers ├── AppServiceProvider.php ├── AuthServiceProvider.php ├── BroadcastServiceProvider.php ├── EventServiceProvider.php └── RouteServiceProvider.php Monolith Initialize a Monolith instance:\nlucid init:monolith app ├── Console ├── Data └── Models ├── Domains ├── Exceptions ├── Foundation ├── Http ├── Policies ├── Providers ├── Services ├── artisan ├── bootstrap ├── composer.json ├── composer.lock ├── config ├── database ├── package.json ├── phpunit.xml ├── public ├── resources ├── routes ├── server.php ├── storage ├── tests └── webpack.mix.js You may also specify a service to begin with:\nlucid init:monolith blog And the following will be added to the initial structure:\napp/Services/Blog ├── Console │ └── Commands ├── Features ├── Operations ├── Http │ ├── Controllers │ └── Middleware ├── Providers │ ├── BlogServiceProvider.php │ ├── BroadcastServiceProvider.php │ └── RouteServiceProvider.php ├── database │ ├── factories │ ├── migrations │ └── seeds ├── resources │ ├── lang │ └── views └── routes ├── api.php ├── channels.php ├── console.php └── web.php For more on the difference between Micro \u0026amp; Monolith and to know how to choose precisely for your application, head over to Micro • Monolith.\nThat\u0026rsquo;s it! You\u0026rsquo;re ready to build something awesome.\nOne last thing to remember: enjoy the journey!\n"},{"uri":"https://docs.lucidarch.dev/upgrade-guide/","title":"Upgrade Guide","tags":[],"description":"","content":" \u0026hellip;\n"},{"uri":"https://docs.lucidarch.dev/contribution-guide/","title":"Contribution Guide","tags":[],"description":"","content":"Bug \u0026amp; Issue Reports To encourage active collaboration, Lucid strongly encourages contribution through pull requests. \u0026ldquo;Bug reports\u0026rdquo; may be searched or created in issues or sent in the form of a pull request containing a failing test or steps to reproduce the bug.\nIf you file a bug report, your issue should contain a title and a clear description of the issue. You should also include as much relevant information as possible and a code sample that demonstrates the issue. The goal of a bug report is to make it easy for yourself - and others - to replicate the bug and develop a fix.\n⏱ PRs and issues are usually checked about three times a week so there is a high chance yours will be picked up soon.\nThe Lucid Architecture source code is on GitHub as lucidarch/lucid.\nSupport Questions Lucid Architecture\u0026rsquo;s GitHub issue trackers are not intended to provide help or support. Instead, use one of the following channels:\nDiscussions is where most conversations takes place For a chat hit us on our official Slack workspace in the #support channel If you prefer StackOverflow to post your questions you may use #lucidarch to tag them Core Development Discussion You may propose new features or improvements of existing Lucid Architecture behaviour in the Lucid Discussins. If you propose a new feature, please be willing to implement at least some of the code that would be needed to complete the feature, or collaborate on active ideation in the meantime.\nInformal discussion regarding bugs, new features, and implementation of existing features takes place in the #internals channel of the Lucid Slack workspace. Abed Halawi, the maintainer of Lucid, is typically present in the channel on weekdays from 8am-5pm EEST (Eastern European Summer Time), and sporadically present in the channel at other times.\nWhich Branch? And How To Contribute The main branch is what contains the latest live version and is the one that gets released.\nFork this repository Clone the forked repository to where you\u0026rsquo;ll edit your code Create a branch for your edits (e.g. feature/queueable-units) Commit your changes and their tests (if applicable) with meaningful short messages Push your branch git push origin feature/queueable-units Open a PR to the main branch, which will run tests for your edits ⏱ PRs and issues are usually checked about three times a week.\nSetup for Development Following are the steps to setup for development on Lucid:\nAssuming we\u0026rsquo;re in ~/dev directory\u0026hellip;\nClone the lucidarch/lucid repository which will create a lucid folder at ~/dev/lucid\nCreate a Laravel project to test your implementation in it composer create-project laravel/laravel myproject\nConnect the created Laravel project to the local Lucid installation; in the Laravel project\u0026rsquo;s composer.json\n\u0026#34;require\u0026#34;: { \u0026#34;...\u0026#34;, \u0026#34;lucidarch/lucid\u0026#34;: \u0026#34;@dev\u0026#34; }, \u0026#34;repositories\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;path\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;~/dev/lucid\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;symlink\u0026#34;: true } } ], \u0026#34;minimum-stability\u0026#34;: \u0026#34;dev\u0026#34;, Make sure you change url to your directory\u0026rsquo;s absolute path\nRun composer update to create the symlink\nNow all your changes in the lucid directory will take effect automatically in the project.\nSecurity Vulnerabilities If you discover a security vulnerability within Lucid, please send an email to Abed Halawi at halawi.abed@gmail.com. All security vulnerabilities will be promptly addressed.\nCoding Style Lucid Architecture follows the PSR-2 coding standard and the PSR-4 autoloading standard.\nPHPDoc Below is an example of a valid Lucid Architecture documentation block. Note that the @param attribute is followed by two spaces, the argument type, two more spaces, and finally the variable name:\n/** * Register a binding with the container. * * @param string|array $abstract * @param \\Closure|string|null $concrete * @param bool $shared * @return void * * @throws \\Exception */ public function bind($abstract, $concrete = null, $shared = false) { // } Code of Conduct The Lucid Architecture code of conduct is derived from the Laravel code of conduct. Any violations of the code of conduct may be reported to Abed Halawi (halawi.abed@gmail.com):\nParticipants will be tolerant of opposing views. Participants must ensure that their language and actions are free of personal attacks and disparaging personal remarks. When interpreting the words and actions of others, participants should always assume good intentions. Behavior that can be reasonably considered harassment will not be tolerated. "},{"uri":"https://docs.lucidarch.dev/getting-started/","title":"Getting Started","tags":[],"description":"","content":" \u0026hellip;\n"},{"uri":"https://docs.lucidarch.dev/micro-vs-monolith/","title":"Micro • Monolith","tags":[],"description":"","content":"Often times we start building our applications with little forecast on how they will evolve over time, they may reach a steady maintainance stage with small tweaks here and there, or undergo pivots that require a high degree of flexibility to not clutter and cause an abundance of technical debt.\nIn both cases, the familiarity with the system\u0026rsquo;s architecture is the guaranteed constant to protect our codebase from going out of bounds.\nLucid is provided in two variants - Micro and Monolith - to accompany a wide range of projects at all stages and provide the versatility of moving between one and the other, which is attributed to the composability of the Lucid stack, where you could use the units you need with no commitment to others - yet like lego bricks they all fit together when the need for them arises.\nMicro A single-purpose project that contains a moderate amount of functionalities that fit in a similar context.\nIt contains the fundamental units of the Lucid stack: Domains, Features, Operations and Data, complementing the Laravel framework:\napp ├── Console │ └── Kernel.php ├── Data └── Models ├── Domains ├── Features ├── Operations ├── Exceptions │ └── Handler.php ├── Http │ ├── Controllers │ ├── Kernel.php │ └── Middleware ├── Policies └── Providers ├── AppServiceProvider.php ├── AuthServiceProvider.php ├── BroadcastServiceProvider.php ├── EventServiceProvider.php └── RouteServiceProvider.php When To Use Micro? Micro is suitable for most projects, including quick prototypes that are ought to become actual products at some point which is where Lucid comes in to reduce the technical debt imposed over time. Or API projects that are meant to be organized for scale.\nAlso as the name suggests they are best suitable for Microservices, where you would have multiple instances of Laravel • Lucid Micro, each representing a microservice in your system.\nMonolith A multi-purpose project that exposes functionality in groups that are best separated into their own contexts physically, mirroring their logical separation and encapsulation. To achieve this we use Services - the differentiating factor of Monolith in the Lucid stack.\nHaving services means we\u0026rsquo;re expanding the functionalities that are available at the framework level, into a contextualised division as an extension. Enabling us to replicate the framework structure into sub-structures that contain routes, controllers, views, resources, tests, features and operations of their own, yet all connected together by sharing code using Domains and Data.\nThere are several ways to segregate services, below we mention two of the most common ways: Multifaceted and Multifunctional.\nExample: Multifaceted Project Is a project that has multiple facets like Api, Admin, Web; where each would have their own way of authenticating users, authorizing requests and responding to them in corresponding formats.\napp ├── Console ├── Data └── Models ├── Domains ├── Exceptions ├── Foundation ├── Http ├── Policies ├── Providers └── Services ├── Admin ├── Api └── Web ├── artisan ├── bootstrap ├── composer.json ├── composer.lock ├── config ├── database ├── package.json ├── phpunit.xml ├── public ├── resources ├── routes ├── server.php ├── storage ├── tests └── webpack.mix.js app/Services/{Admin,Api,Web} ├── Console │ └── Commands ├── Features ├── Operations ├── Http │ ├── Controllers │ └── Middleware ├── Providers │ ├── {Admin,Api,Web}ServiceProvider.php │ ├── BroadcastServiceProvider.php │ └── RouteServiceProvider.php ├── Tests │ ├── Features │ └── Operations ├── database │ ├── factories │ ├── migrations │ └── seeds ├── resources │ ├── lang │ └── views └── routes ├── api.php ├── channels.php ├── console.php └── web.php Example: Multifunction project Is a project with a wide range of functions that are best separated in logic due to the degree of difference in the areas they serve, like an application that has Chat, Product Management, Ecommerce (web UI) and an API.\nThe structure and usage is the same as multifacet, they only differ in concept and their logical separation. As illustrated below, the naming of the services is different between the projects yet their internals are exactly the same. What matters is to choose whichever approach works best for your case and maintain it consistently.\napp ├── Console ├── Data └── Models ├── Domains ├── Exceptions ├── Foundation ├── Http ├── Policies ├── Providers └── Services ├── Chat ├── Ecommerce ├── ProductManagement └── Api ├── artisan ├── bootstrap ├── composer.json ├── composer.lock ├── config ├── database ├── package.json ├── phpunit.xml ├── public ├── resources ├── routes ├── server.php ├── storage ├── tests └── webpack.mix.js app/Services/{Chat,Api,Ecommerce,ProductManagement} ├── Console │ └── Commands ├── Features ├── Operations ├── Http │ ├── Controllers │ └── Middleware ├── Providers │ ├── {Chat,Api,Ecommerce,ProductManagement}ServiceProvider.php │ ├── BroadcastServiceProvider.php │ └── RouteServiceProvider.php ├── Tests │ ├── Features │ └── Operations ├── database │ ├── factories │ ├── migrations │ └── seeds ├── resources │ ├── lang │ └── views └── routes ├── api.php ├── channels.php ├── console.php └── web.php These are only two approaches to services, but there certainly are other creative ways you could benefit from them. Go crazy!\nWhen To Use Monolith? Monolith is suitable for projects that have been pre-defined with a large set of functionalities across multiple sections and are known to grow vertically in functionality as well as horizontally in more areas. However this is not always easy to guess from the start, especially when having to identify the services involved, which is why it will be easy to start with Micro and then move to Monolith when the project has gotten better definition.\nAlso, Monolith projects have been witnessed to grow beyond the initially anticipated scale, to then be split into Microservices themselves, and Lucid happens to be perfect for the case where each of the Services is moved to its own Micro instance.\n"},{"uri":"https://docs.lucidarch.dev/routing/","title":"Routing","tags":[],"description":"","content":"Out of the SOLID principles - of which we are disciples - we\u0026rsquo;ve taken Single Responsibility seriously and created components that define the responsibilities beyond an MVC\u0026rsquo;s controller or any other modern application\u0026rsquo;s entry point, be it a route/request or a command. Which is where it is loose and chaos builds its nest. Within a controller we can do anything, and whichever architecture we follow (or don\u0026rsquo;t) we can still create a mess due to not having a specific guideline that helps contain the chaos.\nHere we define the responsibility of each component starting from MVC and moving through Lucid to keep codebase organised, defined and understandable at a glance, supporting whichever design patterns we decide to adopt:\nRouter A router is like a door that one can open to enter a room. A door does not concern itself with what the room contains or what its purpose is. It is simply a door. However, sometimes we have some security pass for the door to open, so a router can be configured to include components that perform security checks and other forms of entrance preparation.\nResponsibility: Expose a feature from the application over HTTP, routing the request to the corresponding controller method.\nKernel Use Lucid Units (Feature, Job, Operation) to implement your middleware functionality. Code that you may use anywhere else in your application can be easily shared in\nThis space is best to:\nDefine the URL you want your application to allow entries through. Define the controller method that should handle the request and serve the Feature. Perform pre-flight / middleware work such as request authorisation, preparation [does not include input validation]. "},{"uri":"https://docs.lucidarch.dev/controllers/","title":"Controllers","tags":[],"description":"","content":"In an effort to minimize the work of controllers, for they are not here to do work for the application but to point the request in the right direction. In Lucid terms, to serve the intended feature to the user.\nEventually we will end up having one line within each controller method, achieving the thinnest form possible.\nResponsibility: Serve the designated feature.\nWhat you should do in a controller:\nServe a feature. Prepare input as required by the feature that\u0026rsquo;s being served [does not include input validation] Generate Controller Class Use lucid CLI to generate a controller that extends Lucid\u0026rsquo;s Controller class by default, which allows us to serve features features using the built-in serve method.\nMicro Signature lucid make:controller \u0026lt;controller\u0026gt;\nExample\nlucid make:controller Article Generated class will be at app/Http/Controllers/ArticleController.php\nMonolith Signature lucid make:controller \u0026lt;controller\u0026gt; \u0026lt;service\u0026gt;\nExample\nlucid make:controller Article Publishing Generated class will be at app/Services/Publishing/Http/Controllers/ArticleController.php\nFor more details on this command see the help manual with lucid make:controller --help or visit make:controller\nServe Features To serve a Feature from controllers simply call the serve method provided by Lucid\u0026rsquo;s parent controller.\nuse Lucid\\Units\\Controller; use App\\Features\\UpdateArticleFeature; class ArticleController extends Controller { public function articles() { return $this-\u0026gt;serve(new ListArticlesFeature()); } } Request Input The served feature will be able to inject Request class to access request properties. This keeps our controllers clean and allows us to concentrate on what matters to the feature only.\nclass ListArticlesFeature { public function handle(Request $request) { $input = $request-\u0026gt;input(); // or $title = $request-\u0026gt;input(\u0026#39;title\u0026#39;); } } Feature Parameters To pass parameters to a feature, we use the same syntax as dispatching a Laravel job:\nuse Lucid\\Units\\Controller; use App\\Features\\UpdateArticleFeature; class ArticleController extends Controller { public function update($id) { return $this-\u0026gt;serve(UpdateArticleFeature::class, [\u0026#39;id\u0026#39; =\u0026gt; $id]); // OR return $this-\u0026gt;serve(new UpdateArticleFeature(id: $id)); // OR return $this-\u0026gt;serve(new UpdateArticleFeature($id)); } } The id key will be mapped to $id constructor param UpdateArticleFeature::constructor($id).\nParameter and constructor variable names must match. And they\u0026rsquo;re case sensitive!\nWhen using PHP \u0026lt; 8.0, associative arrays as properties has the advantage of disregarding the order in which the parameters are defined which helps maintain a healthy codebase when unit signatures evolve.\nclass UpdateArticleFeature extends Feature { private $id; public function __construct(string $id) { $this-\u0026gt;id = $id; } public function handle(Request $request) { $this-\u0026gt;run(UpdateArticleDataJob::class, [ \u0026#39;id\u0026#39; =\u0026gt; $this-\u0026gt;id, \u0026#39;title\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;title\u0026#39;), \u0026#39;content\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;content\u0026#39;); ]); } } As of PHP 8.0 we use named parameters for better readability and IDE signature recognition:\nclass UpdateArticleFeature extends Feature { public function __construct(private string $id) {} public function handle(Request $request) { $this-\u0026gt;run(new UpdateArticleDataJob( id: $this-\u0026gt;id, title: $request-\u0026gt;input(\u0026#39;title\u0026#39;), content: $request-\u0026gt;input(\u0026#39;content\u0026#39;); )); } } For more on working with features see the Features section.\n"},{"uri":"https://docs.lucidarch.dev/features/","title":"Features","tags":[],"description":"","content":"Represents a human-readable app feature in a class, named the way you would describe it to your colleagues and clients. It contains the logic of implementing the feature with minimum friction and level of detail to remain concise and straight to the point.\nIt runs Lucid Units: Jobs and Operations to perform its tasks. They are thought of as the steps in the process of serving its purpose. A Feature can be served from anywhere, most commonly Controllers and Commands. Can also be queued to run asynchronously using Laravel\u0026rsquo;s powerful Queueing capabilities.\nTechnically, it is a class that encapsulates all the functionalities required for a single request/response lifecycle (or command), in which the handle method represents the task list when you want to implement it in your application.\nExample: This is how a Feature class typically looks like. (simplified)\nclass UpdateProductFeature extends Feature { public function __construct(private string $id) {} public function handle(Request $request) { $this-\u0026gt;run(new ValidateProductInputJob($request-\u0026gt;input())); $product = $this-\u0026gt;run(new SaveProductJob( id: $this-\u0026gt;id, title: $request-\u0026gt;input(\u0026#39;title\u0026#39;), price: $request-\u0026gt;input(\u0026#39;price\u0026#39;), )); return $this-\u0026gt;run(new RespondWithJsonJob($product)); } } Running Lucid Units asynchronously is as simple as having them implement the Queueable interface, applies to all of units such as Jobs and Operations and Features.\nResponsibility: Perform the steps required to accomplish the feature by running Jobs and Operations.\nclass UserController extends Controller { public function login() { return $this-\u0026gt;serve(new LoginUserFeature()); } } Generate Feature Class Use lucid CLI to generate a Feature class that extends Lucid\u0026rsquo;s Feature base class by default, which allows us to run jobs and operations using the built-in run method.\nMicro Signature lucid make:feature \u0026lt;feature\u0026gt;\nExample\nlucid make:feature ListProducts Generated class will be at app/Features/ListProductsFeatures.php\nand its test at tests/Feature/ListProductsFeaturesTest.php\nMonolith Signature lucid make:feature \u0026lt;feature\u0026gt; \u0026lt;service\u0026gt;\nExample\nlucid make:feature ListProducts Commerce Generated class will be at app/Services/Commerce/Features/ListProductsFeatures.php\nand its test at tests/Feature/Services/Commerce/ListProductsFeaturesTest.php\nThe generated Feature class will automatically be suffixed with Feature, so the class above will be ListProductsFeature.\nFeatures can also be generated in subdirectories by specifying their paths\nlucid make:feature Thread/AddThread Forum Generated class will be at app/Services/Forum/Features/Thread/AddThreadFeature.php\nFor more details on this command see the help manual with lucid make:feature --help\nInside Features There are two essential highlights in a feature:\nSignature (a.k.a constructor parameters): Looking at the signature of the Feature should give the idea of what is required for it to be served. handle method: Looking at the class\u0026rsquo;s handle method should provide an overview of the steps required to serve the feature to the user (or any consuming party) without having to know too much details about the inner workings of each step. More on this at below. class CreateArticleFeature extends Feature { public function handle(Request $request) { $this-\u0026gt;run(new ValidateArticleInputJob($request-\u0026gt;input())); $this-\u0026gt;run(new UploadFilesToCDNJob($request-\u0026gt;input(\u0026#39;files\u0026#39;))); $slug = $this-\u0026gt;run(new GenerateSlugJob($request-\u0026gt;input(\u0026#39;title\u0026#39;))); $article = $this-\u0026gt;run(new SaveArticleJob( title: $request-\u0026gt;input(\u0026#39;title\u0026#39;), body: $request-\u0026gt;input(\u0026#39;body\u0026#39;), slug: $slug, )); return $this-\u0026gt;run(new RespondWithJsonJob($article)); } } As shown in the example above, there are several ways to run Jobs in features that are explained in details in the definition of Jobs.\nIt is recommended to always specify the required parameters in each unit\u0026rsquo;s constructor rather than hiding them within the unit. i.e. pass each input parameter separately rather than the entire $request-\u0026gt;input(), or relying on the unit to inject Request class. This way we keep it clear to know what is required for a job or operation to do its work.\nThe handle method Lucid units (Feature, Job, Operation) are simply classes extending Laravel\u0026rsquo;s base Job class with extra functionality that ties them together. Hence, the use of handle method as the invocation point for each of these units.\npublic function handle(Request $request) This method is called automatically when running $this-\u0026gt;serve(Feature::class) or $this-\u0026gt;serve(new Feature()) and it goes through Laravel\u0026rsquo;s IoC to resolve dependencies. In this example we included the Request class to be resolved so that we can access it and pass input to Jobs. Request could\u0026rsquo;ve been any other class in the application that can be resolved using IoC.\npublic function handle(MyCustomClass $mcc) This is the recommended way of using classes to maintain testability by interchanging class instances with their mocks.\nhandle is the same for all Lucid units: Feature, Job and Operation and it behaves the same everywhere.\nServing Features You may serve features from anywhere in your application! Here are some exapmles of doing so.\nHTTP If your controller is generated through the lucid command, all you need to do is call serve within the controller method, otherwise, have your controller (or parent controller) extend Lucid\u0026rsquo;s controller Lucid\\Units\\Controller.\nuse Lucid\\Units\\Controller; use App\\Features\\UpdateProductsFeature; class ProductController extends Controller { public function products() { return $this-\u0026gt;serve(new ListProductsFeature()); } } Command To run a feature from the command we just need to equip our Command class with Lucid\u0026rsquo;s methods by simply using ServesFeatures\nuse Illuminate\\Console\\Command; use App\\Features\\CleanStaleCartsFeature; use Lucid\\Bus\\ServesFeatures; class CleanStaleCarts extends Command { use ServesFeatures; protected $signature = \u0026#39;clean:carts --stale\u0026#39;; protected $description = \u0026#34;Cleans inactive customer carts.\u0026#34;; public function handle() { return $this-\u0026gt;serve(new CleanStaleCartsFeature()); } } Other Just like we did for Commands we may do the same in any class we want, by simply using ServesFeatures the serve method will be available.\nuse App\\Features\\DoSomethingFeature; use Lucid\\Bus\\ServesFeatures; class ToServeFeaturesHere { use ServesFeatures; public function give() { return $this-\u0026gt;serve(new GiveHighFiveFeature()); } } Testing When generating a feature with lucid make:feature a test class is automatically generated along, having markIncomplete() statement in a stub method as a reminder to fill the missing test.\nMicro lucid make:feature ListProductsFeature\nWould generate two files:\napp/Features/ListProductsFeature tests/Feature/ListProductsFeatureTest Monolith lucid make:feature ListProductsFeature api\nWould generate two files:\napp/Services/Api/Features/ListProductsFeature tests/Feature/Services/Api/ListProductsFeatureTest Since Monolith is about scope and distribution of responsibility, and features are a scope of a service, tests are distributed and scoped accordingly in the corresponding service.\nFeature tests are equivalent to functional tests in a typical application. It is about testing how the feature would behave with a certain input combination from a user\u0026rsquo;s perspective.\nIf the feature is served over an HTTP request, the test would be about actually requesting the URL and passing parameters to receive the expected output, in addition to further assertions in the case of storage or other application aspects that require further assertion.\nThe example below is incomplete and is for illustrative purposes only (e.g. $fake must be defined).\nclass UpdateProductDetailsFeatureTest extends TestCase { public function test_successful_product_details_update() { $product = [ \u0026#39;id\u0026#39; =\u0026gt; $fake-\u0026gt;uuid, \u0026#39;title\u0026#39; =\u0026gt; $fake-\u0026gt;sentence, \u0026#39;description\u0026#39; =\u0026gt; $fake-\u0026gt;text, \u0026#39;price\u0026#39; =\u0026gt; $faker-\u0026gt;randomNumber(2), ]; // request $response = $this-\u0026gt;put(\u0026#34;/products/{$product[\u0026#39;id\u0026#39;]}\u0026#34;, $product); $response-\u0026gt;assertStatus(200) -\u0026gt;assertJson([ \u0026#39;updated\u0026#39; =\u0026gt; true ]); // storage $stored = Product::find($production[\u0026#39;id\u0026#39;]); $this-\u0026gt;assertEquals($product, $stored-\u0026gt;toArray()); } public function test_failing_product_details_update() { $product = [ \u0026#39;id\u0026#39; =\u0026gt; $fake-\u0026gt;uuid, \u0026#39;title\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, // cannot be empty \u0026#39;description\u0026#39; =\u0026gt; $fake-\u0026gt;text, \u0026#39;price\u0026#39; =\u0026gt; $faker-\u0026gt;randomNumber(2), ]; $response = $this-\u0026gt;put(\u0026#34;/products/{$product[\u0026#39;id\u0026#39;]}\u0026#34;, $product); $response-\u0026gt;assertStatus(200) -\u0026gt;assertJson([ \u0026#39;updated\u0026#39; =\u0026gt; false, \u0026#39;error\u0026#39; =\u0026gt; [ \u0026#39;messages\u0026#39; =\u0026gt; [\u0026#39;title field is required.\u0026#39;], ], ]); // storage - ensure original title is still in place $stored = Product::find($production[\u0026#39;id\u0026#39;]); $this-\u0026gt;assertEquals(\u0026#39;previous title\u0026#39;, $stored-\u0026gt;title); } } As far as functional testing goes, it is best to portray the usage of the feature from a broad perspective rather than digging into every detail of the steps of the function. Feature testing is usually considered to be the integration test between the units that make up the feature.\nMocking It is recommended with feature tests to only mock what\u0026rsquo;s external to your application to preserve the quality guarantee . Mocks are usually for 3rd-party APIs and other services that we integrate with, but not for internals such as storage.\nFor this example we will assume that this feature runs from a command line rather than over HTTP.\nThis example contains missing variables and is for illustrative purposes only.\napp/Features/UpdateFacebookPostsFeature.php\nclass UpdateFacebookPostsFeature extends Feature { public function handle() { $posts = $this-\u0026gt;run(new FetchFacebookPostsJob()); $this-\u0026gt;run(new StoreFacebookPostsJob( posts: $posts, )); } } app/Domains/Facebook/Jobs/FetchFacebookPostsJob.php\nclass FetchFacebookPostsJob extends Job { public function handle(FacebookClient $fb) { return $fb-\u0026gt;posts(); } } tests/Feature/UpdateFacebookPostsFeatureTest.php\nclass UpdateFacebookPostsFeatureTest extends TestCase { public function test_successfully_fetching_facebook_posts() { $mFB = Mockery::mock(FacebookClient::class); $mFB-\u0026gt;shouldReceive(\u0026#39;get\u0026#39;)-\u0026gt;with($args)-\u0026gt;andReturn($payload); $this-\u0026gt;app-\u0026gt;instance(FacebookClient::class, $mFB); $f = new UpdateFacebookPosts(); $result = $f-\u0026gt;handle(); // 0 in CLI means success! $this-\u0026gt;assertEquals(0, $result); } } As shown in FetchFacebookPostsJob the client has been injected, so we had to replace the instance in IoC to load our mocked instance instead of the real one.\nFAQ What not to do in a feature? Complex conditional logic: The feature passes output from Jobs and Operations but it barely knows anything about what goes on inside them. It only knows the sequence in which they should run and [maybe] some basic logic that is better be avoided and delegated to jobs and operations of possible. Process output from units: Parsing and transformation of content is best done in Job or an Operation. The output returned by a these units should always go as-is to the next unit. The feature doesn\u0026rsquo;t know much about the internals of steps or how they are actually performed. It is only aware of the sequence of the steps and the requirements of the different units through their signatures. This guarantees consistency and predictability when reading the feature\u0026rsquo;s code in the handle method and allows anyone new to the code to skim through quickly and have an idea about the required steps. Call another Feature: In order to avoid the Pyramid of Doom and reduce the cognitive load required to navigate the codebase and understand the code, Features should not call each other. Though the same feature may be called numerous times as long as it does not add up to the Feature\u0026rsquo;s complexity. [Monolith] What to do about duplicate functionality between services? TL;DR It is recommended to have similar features across services than share features between them. Even if it meant repeating the same sequence of units.\nSince Monolith is all about separation of concerns per service, when dealing with multiple sides of the same application (e.g. Api, CMS, Web UI, etc.) we\u0026rsquo;d need to deal with their features differently; maybe not at the beginning but eventually we\u0026rsquo;ll find ourselves dealing with too many options and cramming a lot of confusing parameters in the same feature because we decided to share it with multiple services. To avoid all this, it is best to create a feature per service even if it means to repeat the same sequence of units. Below is a brief example to illustrate it.\nShared Feature\nSupposing that we decided to move the feature class from app/Services/{service}/Features to a place all services may access like app/Features/UpdateProductDetailsFeature.php and we\u0026rsquo;d like our Api and Web services to use it. This feature should serve the response in JSON when in the Api service and return a view when in Web:\nclass UpdateProductDetailsFeature { private $isApi; public function __construct(bool $isApi) { $this-\u0026gt;isApi = $isApi; } public function handle(Request $request) { $this-\u0026gt;run(new ValidateProductDeatilsInputJob( input: $request-\u0026gt;input() )); $product = $this-\u0026gt;run(new UpdateProductDetailsJob( title: $request-\u0026gt;input(\u0026#39;title\u0026#39;), description: $request-\u0026gt;input(\u0026#39;description\u0026#39;), price: $request-\u0026gt;input(\u0026#39;price\u0026#39;), )); if ($this-\u0026gt;isApi) { return $this-\u0026gt;run(new RespondWithJsonJob($product)); } return $this-\u0026gt;run(new RespondWithViewJob( view: \u0026#39;product\u0026#39;, data: compact(\u0026#39;product\u0026#39;), )); } } This is yet a simple example but if we were to add more conditions to customize the experience further, we\u0026rsquo;d be throwing plenty of $this-\u0026gt;isApi everywhere in our feature. For example: the user reference from the API is a token, while the one from the Web is an ID retrieved from the session. Here\u0026rsquo;s how it would look like:\npublic function handle(Request $request) { $this-\u0026gt;run(new ValidateProductDeatilsInputJob( input: $request-\u0026gt;input() )); if ($this-\u0026gt;isApi) { $user = $this-\u0026gt;run(new GetUserByApiTokenJob( token: $request-\u0026gt;input(\u0026#39;token\u0026#39;), )); } else { $user = $this-\u0026gt;run(new GetUserFromSessionJob()); } $product = $this-\u0026gt;run(new UpdateProductDetailsJob( title: $request-\u0026gt;input(\u0026#39;title\u0026#39;), description: $request-\u0026gt;input(\u0026#39;description\u0026#39;), price: $request-\u0026gt;input(\u0026#39;price\u0026#39;), user: $user, )); if ($this-\u0026gt;isApi) { return $this-\u0026gt;run(new RespondWithJsonJob($product)); } return $this-\u0026gt;run(new RespondWithViewJob( view: \u0026#39;product\u0026#39;, data: compact(\u0026#39;product\u0026#39;), )); } Ugly, isn\u0026rsquo;t it? See the other example for a cleaner approach below.\nFeature per Service\nApi::UpdateProductDetailsFeature\nlocated at app/Services/Api/Features/UpdateProductDetailsFeature.php\nclass UpdateProductDetailsFeature { public function handle(Request $request) { $this-\u0026gt;run(new ValidateProductDeatilsInputJob( input: $request-\u0026gt;input() )); $user = $this-\u0026gt;run(new GetUserByApiTokenJob( token: $request-\u0026gt;input(\u0026#39;token\u0026#39;), )); $product = $this-\u0026gt;run(new UpdateProductDetailsJob( title: $request-\u0026gt;input(\u0026#39;title\u0026#39;), description: $request-\u0026gt;input(\u0026#39;description\u0026#39;), price: $request-\u0026gt;input(\u0026#39;price\u0026#39;), user: $user, )); return $this-\u0026gt;run(new RespondWithViewJob( data: compact(\u0026#39;product\u0026#39;), view: \u0026#39;web.product.update\u0026#39;, )); } } Web::UpdateProductDetailsFeature\nlocated at app/Services/Web/Features/UpdateProductDetailsFeature.php\nclass UpdateProductDetailsFeature { public function handle(Request $request) { $this-\u0026gt;run(new ValidateProductDeatilsInputJob( input: $request-\u0026gt;input() )); $user = $this-\u0026gt;run(new GetUserFromSessionJob()); $product = $this-\u0026gt;run(new UpdateProductDetailsJob( title: $request-\u0026gt;input(\u0026#39;title\u0026#39;), description: $request-\u0026gt;input(\u0026#39;description\u0026#39;), price: $request-\u0026gt;input(\u0026#39;price\u0026#39;), user: $user, )); return $this-\u0026gt;run(new RespondWithViewJob( view: \u0026#39;product\u0026#39;, data: compact(\u0026#39;product\u0026#39;), )); } } "},{"uri":"https://docs.lucidarch.dev/jobs/","title":"Jobs","tags":[],"description":"","content":"Jobs do the actual work by implementing the business logic. Being the smallest unit in Lucid, a Job should do one thing, and one thing only - that is: perform a single task. They are the snippets of code we wish we had sometimes, and are pluggable to use anywhere in our application.\nOur objective with Jobs is to limit the scope of a single functionality so that we know where to look when finding it, and when we\u0026rsquo;re within its context we don\u0026rsquo;t tangle responsibility with other jobs to achieve the ultimate form of single responsibility principle.\nUsually called by a Feature or an Operation, but can be called from anywhere by any other class once setup as a custom dispatcher; hence, being the most shareable pieces of code.\nJobs in Domains Domains are where jobs live. It is how they\u0026rsquo;re organized in the folder structure, and represent the execution point of a single functionality within the corresponding domain. In other words, the only way to access a domain should be through a Job.\nHere\u0026rsquo;s an example of two domains (User \u0026amp; Product) exposing functionality through jobs.\nUser [domain] LoginUserJob LogoutUserJob UpdateUserProfileJob Product [domain] FindProductByIDJob SearchForProductJob SaveProductDetailsJob ValidateProductDetailsJob Each of these is a class. Similar to other Lucid units it uses __constructor to define required parameters and is executed through the handle method when calling run.\nExample\nIn a Feature or Operation we can use $this-\u0026gt;run(ValidateProductDetailsJob::class) or $this-\u0026gt;run(new ValidateProductDetailsJob()) to run the job\u0026rsquo;s handle method.\napp/Domains/Product/ValidateProductDetailsJob\nuse Lucid\\Units\\Job; use App\\Domains\\Product\\ProductValidator; class ValidateProductDetailsJob extends Job { private array $input; public function __constructor(array $input) { $this-\u0026gt;input = $input; } /** * @param ProductValidator $validator * * @throws InvalidInputException */ public function handle(ProductValidator $validator) { $validator-\u0026gt;validate($this-\u0026gt;input); } } And in our feature: .../Features/AddProductFeature.php\nuse App\\Domains\\Http\\Jobs\\RespondWithJsonJob; use App\\Domains\\Product\\Jobs\\SaveProductDetailsJob; use App\\Domains\\Product\\Jobs\\ValidateProductDetailsJob; class AddProductFeature extends Feature { public function handle(Request $request) { $this-\u0026gt;run(new ValidateProductDetailsJob( input: $request-\u0026gt;input(), )); $product = $this-\u0026gt;run(new SaveProductDetailsJob( title: $request-\u0026gt;input(\u0026#39;title\u0026#39;), price: $request-\u0026gt;input(\u0026#39;price\u0026#39;), description: $request-\u0026gt;input(\u0026#39;description\u0026#39;), )); return $this-\u0026gt;run(new RespondWithJsonJob($product)); } } Characteristics Unlike other units (feature \u0026amp; operation), jobs don\u0026rsquo;t call other jobs to avoid obscure nested logic that end up being hard to follow and maintain. Jobs do not know about other units, they operate in isolation and are unaware of their surroundings. If they were people, they would\u0026rsquo;ve been called selfish for only being concerned with themselves and their needs to perform their task. Constructor parameters of a job - a.k.a. job signature - should be about the job itself only, not concerned with where it will be called from and in which conditions. Here\u0026rsquo;s a personification of a Job speaking: I, as a Job, in order to fulfill my task, I need \u0026ldquo;X\u0026rdquo; and \u0026ldquo;Y\u0026rdquo;, and once I am done I will return \u0026ldquo;Z\u0026rdquo; to you.\nTo validate your choice with jobs, simply ask yourself: \u0026ldquo;what does this job do?\u0026rdquo; and the answer should be \u0026ldquo;It [does this] then returns [that]\u0026rdquo; where:\n[does this]: should not include an \u0026ldquo;and\u0026rdquo; and should be made up of few words (single responsibility) [that]: ideally should either be an object, or a status response (boolean). TIP: Avoid returning associative arrays as much as possible, or at all if possible. They ramp up undefined structures and it will require more cognitive load over time to figure out their structures and values.\nIt is common practice to share jobs, in fact they are the units that are shared the most in code. For that reason we strive to make their code cover the entire spectrum of the task they perform, while careful not to end up having complex jobs just for the sake of reusing them.\nGood balance between complexity and functionality is key with jobs, it gets better with time and the more you familiarize yourself with Lucid!\nGenerate Job Class Use lucid CLI to generate a Job class that extends Lucid\u0026rsquo;s Job base class by default, which handle method is invoked when run by an Operation, Feature or a custom dispatcher.\nMicro Signature lucid make:job \u0026lt;job\u0026gt; \u0026lt;domain\u0026gt; {--Q|queue}\nExample\nlucid make:job FindProduct product Generated class will be at app/Domains/Product/Jobs/FindProductJob.php\nand its test at tests/Unit/Domains/Product/Jobs/FindProductJobTest.php\nMonolith Signature lucid make:job \u0026lt;job\u0026gt; \u0026lt;domain\u0026gt; {--Q|queue}\nExample\nlucid make:job FindProduct product Generated class will be at app/Domains/Product/Jobs/FindProductJob.php\nand its test at tests/Unit/Domains/Product/Jobs/FindProductJobTest.php\nThe generated Job class will automatically be suffixed with Job, so there\u0026rsquo;s no need for it to be specified in the command.\nFor more details on this command see the help manual with lucid make:job --help\nCalling Jobs Jobs are called using the run method that\u0026rsquo;s provided by extending one of Lucid\u0026rsquo;s runner units Feature \u0026amp; Operation classes, which internally relies on UnitDispatcher trait.\nSignature\nrun($job, $arguments = [], $extra = [])\n$job can be either a Job instance or the job\u0026rsquo;s class name (usually using SomeJob::class) [$arguments] is the associative array of arguments mapping the Job\u0026rsquo;s constructor parameters. Only used when $job is the class name and not the instance. [$extra] is for the Laravel dispatcher and is not used by Lucid for any purposes, passed straight to the dispatcher. Dispatching Jobs \u0026amp; Arguments Given this sample job that updates a product\u0026rsquo;s info in the database:\nnamespace App\\Domains\\Product\\Jobs; class UpdateProductDetailsJob extends Job { public function __construct(int $id, string $title, string $price, string $description) { $this-\u0026gt;id = $id $this-\u0026gt;title = $title $this-\u0026gt;price = $price $this-\u0026gt;description = $description } public function handle(): bool { $product = Product::find($this-\u0026gt;id); $product-\u0026gt;fill([ \u0026#39;title\u0026#39; =\u0026gt; $this-\u0026gt;title, \u0026#39;price\u0026#39; =\u0026gt; $this-\u0026gt;price, \u0026#39;description\u0026#39; =\u0026gt; $this-\u0026gt;description, ]); return $product-\u0026gt;save(); } } Calling this job from a feature or an operation is straight forward using run():\n$this-\u0026gt;run(new UpdateProductDetailsJob( id: $request-\u0026gt;input(\u0026#39;id\u0026#39;), title: $request-\u0026gt;input(\u0026#39;title\u0026#39;), price: $request-\u0026gt;input(\u0026#39;price\u0026#39;), description: $request-\u0026gt;input(\u0026#39;description\u0026#39;), )); $arguments are sent as an associative array where the key should match parameters\u0026rsquo; names exactly, but not their order. Meaning that we could tangle parameter order, reducing the amount of change required when updating the job with new order of arguments or additional optional ones.\nThis would still work:\n$this-\u0026gt;run(new UpdateProductDetailsJob( title: $request-\u0026gt;input(\u0026#39;title\u0026#39;), description: $request-\u0026gt;input(\u0026#39;description\u0026#39;), price: $request-\u0026gt;input(\u0026#39;price\u0026#39;), id: $request-\u0026gt;input(\u0026#39;id\u0026#39;), )); Also, aesthetically allows to organize parameters by length which is nicer to look at!\nThis is the recommended way of calling jobs, for it makes reading run statements in features and operations explicit and requires a reduced amount of knowledge, which preserves mental space for what actually matters.\nDispatching Job Instances\nGiven this simple job that retrieves a user from the DB by their identifier:\nnamespace App\\Domains\\User\\Jobs; class GetUserJobID extends Job { private int $id; public function __construct(int $id) { $this-\u0026gt;id = $id; } public function handle() { return User::find($this-\u0026gt;id); } } We can simply initialize an instance and run it:\n$this-\u0026gt;run(new GetUserByIDJob($userId)); and it works exactly the same as if we did run(GetUserByIDJob::class, ['id' =\u0026gt; $userId]).\n$arguments won\u0026rsquo;t apply when an initialized job is run.\nSince the job requires only one argument, and looking at the run line is intuitively indicative of the intended functionality and the argument, we can simply initialize the job ourselves and pass it to the dispatcher.\nThis is familiar with jobs that are known to (almost) never need to evolve beyond their initial functionality, and is surely not recommended when the job requires two or more parameters because of the extra effort required to figure out the parameters when reading run statements.\nTake for example the case of a job with more parameters:\n$this-\u0026gt;run(new UpdateProductDetailsJob($id, $title, $description, $price)) instead of this:\n$this-\u0026gt;run(new UpdateProductDetailsJob( id: $id, price: $price, title: $title, description: $description, )); Choosing Between Initialization \u0026amp; Separate Arguments\nAs mentioned above, it is recommended to always use named parameters for it makes code easier to read when there are multiple jobs in a sequence.\nHere\u0026rsquo;s a comparison of the two approaches in the following handle method, could be for a feature or an operation:\nSeparate: A bit more writing but clearer when reading.\npublic function handle(Request $request) { $this-\u0026gt;run(new ValidateProductInputJob( input: $request-\u0026gt;input(), )); $photos = $this-\u0026gt;run(new UploadProductPicturesJob( cover: $request-\u0026gt;input(\u0026#39;pictures.cover\u0026#39;), showcase: $request-\u0026gt;input(\u0026#39;pictures.showcase\u0026#39;), )); $product = $this-\u0026gt;run(new CreateProductJob( title: $request-\u0026gt;input(\u0026#39;title\u0026#39;), price: $request-\u0026gt;input(\u0026#39;price\u0026#39;), description: $request-\u0026gt;input(\u0026#39;description\u0026#39;), provider: $request-\u0026gt;input(\u0026#39;provider\u0026#39;), photos: $photos )); $isStockUpdated = $this-\u0026gt;run(new UpdateProductStockAvailabilityJob( id: $product-\u0026gt;id, availableCount: $request-\u0026gt;input(\u0026#39;available_count\u0026#39;), )); return $this-\u0026gt;run(new RespondWithViewJob( data: $product, template: \u0026#39;product.update\u0026#39;, )); } Initialized: Fast to write but harder to read.\npublic function handle(Request $request) { $this-\u0026gt;run(new ValidateProductInputJob($request-\u0026gt;input)); $photos = $this-\u0026gt;run(new UploadProductPicturesJob( $request-\u0026gt;input(\u0026#39;pictures.cover\u0026#39;), $request-\u0026gt;input(\u0026#39;pictures.showcase\u0026#39;)) ); $product = $this-\u0026gt;run(new CreateProductJob( $request-\u0026gt;input(\u0026#39;title\u0026#39;), $request-\u0026gt;input(\u0026#39;price\u0026#39;), $request-\u0026gt;input(\u0026#39;description\u0026#39;), $request-\u0026gt;input(\u0026#39;provider\u0026#39;), $photos) ); $isStockUpdated = $this-\u0026gt;run(new UpdateProductStockAvailabilityJob( $product-\u0026gt;id, $request-\u0026gt;input(\u0026#39;available_count\u0026#39;)); } Queuable Jobs You may turn any job into a queueable job that will be dispatched using Laravel Queues rather than running synchronously, by simply implementing ShouldQueue interface.\nGenerate Queueable Job lucid make:job UploadPhotos files --queue Will produce the following job class:\nclass UploadPhotosJob extends Job implements ShouldQueue { public function handle() { // photo uploads will be processed in the queue } } This job will be treated exactly as Laravel treats queued jobs.\nSpecify Queue Name public function __construct() { /* * set the name of the queue on which to dispatch this job. * if using Horizon, this should be the same as the one configured there. */ $this-\u0026gt;onQueue(\u0026#39;emails\u0026#39;); } Custom Dispatcher You may turn any class in your application into a job dispatcher. To equip a class for running jobs use Lucid\\Bus\\UnitDispatcher trait.\nuse Lucid\\Bus\\UnitDispatcher; class Handler extends ExceptionHandler { use UnitDispatcher; public function custom() { return $this-\u0026gt;run(new TheJob()); } } Handling Errors with Jobs It is common to want to dispatch jobs from Exceptions\\Handler, where you may want to centralize your error responses in jobs to maintain a consistent structure across your application.\nAssuming that we are working on an API where all our errors must be returned in JSON format, to avoid the accidental rendering of an HTML page leading to unexpected behaviours. We would create a job to be run when encountering an exception that includes the response structure. Lucid ships with one that can be used as default, available in the built-in Http domain App\\Domains\\Http\\Jobs\\RespondWithJsonErrorJob which has a simple signature:\n$this-\u0026gt;run(new RespondWithJsonErrorJob( options: 0, // will be passed to ResponseFactory::json() code: 2900, // custom error code, optional, default: 400 status: 400, // HTTP response status code, optional, default: 400 headers: [], // customize headers message: $e-\u0026gt;getMessage(), )); Running this job in response to our exceptions will guarantee that the consumer always receives a consistent JSON structure:\n{ \u0026#34;status\u0026#34;: 400, \u0026#34;error\u0026#34;: { \u0026#34;code\u0026#34;: 2900, \u0026#34;message\u0026#34;: \u0026#34;Expressive message about the error.\u0026#34; } } Rendering Exceptions In our Handler class we can register a custom rendering Closure for exceptions of a given type and use the job to render JSON.\nuse App\\Exceptions\\CustomException; /** * Register the exception handling callbacks for the application. * * @return void */ public function register() { $this-\u0026gt;renderable(function (CustomException $e, $request) { return $this-\u0026gt;run(new RespondWithJsonErrorJob( status: 500, message: $e-\u0026gt;getMessage(), )); }); } You may also wish to return a view in the case of an HTML response instead:\nuse App\\Exceptions\\CustomException; /** * Register the exception handling callbacks for the application. * * @return void */ public function register() { $this-\u0026gt;renderable(function (CustomException $e, $request) { return $this-\u0026gt;run(new RespondWithViewJob( status: 500, template: \u0026#39;errors.custom\u0026#39;, )); }); } Reportable \u0026amp; Renderable Exceptions Similar to our Handler class, we may have our exceptions render themselves by defining render method in the exception class.\nnamespace App\\Exceptions; use Exception; use Lucid\\Bus\\UnitDispatcher; class RenderException extends Exception { use UnitDispatcher; /** * Render the exception into an HTTP response. * * @param \\Illuminate\\Http\\Request $request * @return \\Illuminate\\Http\\Response */ public function render($request) { return $this-\u0026gt;run(new RespondWithJsonErrorJob( status: 500, message: $this-\u0026gt;getMessage(), )); } } Testing When generating a job with lucid make:job a test class is automatically generated along, having markIncomplete() statement in a stub method as a reminder to fill the missing test.\nTheir locations help us encapsulate our domains since they would contain all they need to operate in isolation.\nMicro lucid make:job UpdateProductDetails product Would generate two files:\napp/Domains/Product/Jobs/UpdateProductDetailsJob tests/Unit/Domains/Product/Jobs/UpdateProductDetailsJobTest Monolith lucid make:job UpdateProductDetails product Would generate two files:\napp/Domains/Product/Jobs/UpdateProductDetailsJob tests/Unit/Domains/Product/Jobs/UpdateProductDetailsJobTest The example below illustrates a simplified version of testing user input validation job:\nnamespace Tests\\Unit\\Domains\\User\\Jobs; use Tests\\TestCase; use Lucid\\Exceptions\\InvalidInputException; use App\\Domains\\User\\Jobs\\ValidateUserProfileInputJob; class ValidateUserProfileInputJobTest extends TestCase { public function test_passes_validation() { $data = [ \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;John Doe\u0026#39;, \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;john@example.com\u0026#39;, \u0026#39;occupation\u0026#39; =\u0026gt; \u0026#39;Fun Seeker\u0026#39;, ]; $job = new ValidateUserProfileInputJob($data); $isValid = $job-\u0026gt;handle(); $this-\u0026gt;assertTrue($isValid); } public function test_fails_with_empty_name() { $this-\u0026gt;expectException(InvalidInputException::class); $this-\u0026gt;expectExceptionMessage(\u0026#39;The name field is required.\u0026#39;); $invalid = [ \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;john@example.com\u0026#39;, \u0026#39;occupation\u0026#39; =\u0026gt; \u0026#39;Fun Seeker\u0026#39;, ]; $job = new ValidateUserProfileInputJob($invalid); $job-\u0026gt;handle(); } } Mocking In most cases you wouldn\u0026rsquo;t want to mock with jobs because they are the actual units of work that need to be tested, though there would still be cases where you must mock. E.g. fetching content from an external source as illustrated in the example below, where we have a job to fetch articles from dev.to to test.\nOur job looks like this:\nnamespace App\\Domains\\DevTo\\Jobs; use Lucid\\Units\\Job; use App\\Domains\\DevTo\\Client; use Illuminate\\Support\\Collection; class FetchDevToArticlesJob extends Job { public function handle(Client $devto): Collection { $articles = $devto-\u0026gt;articles(); return collect($articles); } } Client class code has been omitted, needless to say it is where the connection to dev.to happens to retrieve the articles:\nTest\nnamespace Tests\\Unit\\Domains\\DevTo\\Jobs; use Mockery; use Tests\\TestCase; use App\\Domains\\DevTo\\Client; use Illuminate\\Support\\Collection; use App\\Domains\\DevTo\\Jobs\\FetchDevToArticlesJob; class FetchDevToArticlesJobTest extends TestCase { public function test_fetch_dev_to_articles_job() { $expected = json_encode([ \u0026#39;expected\u0026#39; =\u0026gt; \u0026#39;response\u0026#39;, \u0026#39;goes\u0026#39; =\u0026gt; \u0026#39;here\u0026#39;, ], true); // mock client $mClient = Mockery::mock(Client::class); $mClient-\u0026gt;shouldReceive(\u0026#39;articles\u0026#39;)-\u0026gt;withNoArgs()-\u0026gt;andReturn($expected); $job = new FetchDevToArticlesJob(); // execute job with injected mocked client $articles = $job-\u0026gt;handle($mClient); $this-\u0026gt;assertInstanceOf(Collection::class, $articles); } } "},{"uri":"https://docs.lucidarch.dev/operations/","title":"Operations","tags":[],"description":"","content":"Their purpose is to increase the degree of code reusability by piecing jobs together to provide composite functionalities from across domains.\nOperations are a group of jobs that deliver multi-step functionalities. Technically, Operation classes are similar to Feature classes in usage; meaning that they both have run($job,$params) in common to run jobs from any domain, and can be called standalone (e.g. call an operation from a Command).\nHowever, conceptually they have their differences in that a Feature can run multiple Operation and Job classes while an Operation can run multiple Jobs only. They also differ in what they represent to the application: A feature is what the application provides to the outside, while an operation is more of an internal aspect. Technically they differ in they way they are dispatched, where we serve a feature but we run an operation; any class can do so the same as a Feature class would by turning it into a dispatcher class.\nExample\nGiven that we are working on a publishing platform, and upon creating an article we would like to send notifications to the subscribers of the author, here\u0026rsquo;s what that operation may look like:\nclass NotifySubscribersOperation extends Operation { private int $authorId; public function __construct(int $authorId) { $this-\u0026gt;authorId = $authorId; } /** * Sends notifications to subscribers. * * @return int Number of notification jobs enqueued. */ public function handle(): int { $author = $this-\u0026gt;run(new GetAuthorByIDJob( id: $this-\u0026gt;authorId, )); do { $result = $this-\u0026gt;run(new PaginateSubscribersJob( authorId: $this-\u0026gt;authorId, )); if ($result-\u0026gt;subscribers-\u0026gt;isNotEmpty()) { // it\u0026#39;s a queueable job so it will be enqueued, no waiting time $this-\u0026gt;run(new SendNotificationJob( from: $author, to: $result-\u0026gt;subscribers, notification: \u0026#39;article.published\u0026#39;, )); } } while ($result-\u0026gt;hasMorePages()); return $result-\u0026gt;total; } } As you see the jobs that are used in this operation are ones that can be shared with other areas in our code as well, increasing the degree of reusable code.\nGetAuthorByIDJob: to retrieve a user/author by ID is as abstract as it can get, and will definitely be used numerous times in our application.\nPaginateSubscribersJob: would be used every time we need to retrieve an author\u0026rsquo;s subscribers. Such jobs usually grow in responsibility over time and their results become more customizable.\nExample: later it may allow to specify a certain limit to the number of subscribers to return, then we\u0026rsquo;d be able to paginate them for listing subscribers in a view or over an API.\nSendNotificationJob: will be used every time we need to send a notification, regardless of the type of notification to be sent since it is specified with the notification parameter. Which also can grow into providing more customization such as specifying the type of notification to send (e.g. mobile, browser, web, email etc.).\nWith this we\u0026rsquo;ve achieved single responsibility at a low cost of debt and prepared for scale. In fact, some of these jobs would\u0026rsquo;ve been implemented already by the time we reached this operation which makes it quick to biuld.\nNow we have that functionality bundled at our disposal to be called whenever needed:\n$this-\u0026gt;run(new NotifySubscribersOperation( authorId: $authorId, )); Generate Operation Class Use lucid CLI to generate an Operation class that extends Lucid\u0026rsquo;s Operation base class by default, which handle method is invoked when run by a Feature or a custom dispatcher.\nMicro Signature lucid make:operation \u0026lt;operation\u0026gt; {--Q|queue}\nExample\nlucid make:operation NotifySubscribers Generated class will be at app/Operations/NotifySubscribersOperation.php\nand its test at tests/Unit/Operations/NotifySubscribersOperationTest.php\nMonolith Signature lucid make:operation \u0026lt;operation\u0026gt; \u0026lt;service\u0026gt; {--Q|queue}\nExample\nlucid make:operation NotifySubscribers publishing Generated class will be at app/Services/Publishing/Operations/NotifySubscribersOperation.php\nand its test at tests/Unit/Services/Publishing/Operations/NotifySubscribersOperationTest.php\nThe generated Operation class will automatically be suffixed with Operation, so there\u0026rsquo;s no need for it to be specified in the command.\nCalling Operations Similar to jobs, and Operation can also be called using the run method that\u0026rsquo;s provided by extending one Lucid\u0026rsquo;s Feature or a custom dispatcher,\nSee here for more on the run method.\nclass PublishArticleFeature extends Feature { $this-\u0026gt;run(new ValidateArticlePublishingInputJob($request-\u0026gt;input())); $this-\u0026gt;run(new SetArticlePublishingRulesOperation( id: $request-\u0026gt;input(\u0026#39;id\u0026#39;), schedule: $request-\u0026gt;input(\u0026#39;datetime\u0026#39;), platforms: $request-\u0026gt;input(\u0026#39;platforms\u0026#39;), visibility: $request-\u0026gt;input(\u0026#39;visibility\u0026#39;), )); $this-\u0026gt;run(new NotifySubscribersOperation( authorId: Auth::id(), )); $article = $this-\u0026gt;run(new GetArticleByIDJob($request-\u0026gt;input(\u0026#39;id\u0026#39;))); return $this-\u0026gt;run(new RespondWithViewJob( data: compact(\u0026#39;article\u0026#39;), template: \u0026#39;articles.publish.success\u0026#39;, )); } Queueable Operations You may turn any operation into a queueable operation that will be dispatched using Laravel Queues rather than running synchronously, by simply implementing ShouldQueue interface.\nGenerate Queueable Operation Use the --queue or shorthand -Q to generate a queueable operation.\nlucid make:job NotifySubscribers --queue Will produce the following operation class:\nclass NotifySubscribersOperation extends Operation implements ShouldQueue { public function handle() { // notifications processing will happen in the queue } } This job will be treated exactly as Laravel treats queued jobs.\nSpecify Queue Name public function __construct() { /* * set the name of the queue on which to dispatch this operation. * if using Horizon, this should be the same as the one configured there. */ $this-\u0026gt;onQueue(\u0026#39;notifications\u0026#39;); } Testing When generating an operation with lucid make:operation a test class is automatically generated along, having markIncomplete() statement in a stub method as a reminder to fill the missing test.\nMicro lucid make:operation NotifySubscribers Would generate two files:\napp/Operations/NotifySubscribersOperation.php tests/Unit/Operations/NotifySubscribersOperationTest.php Monolith lucid make:operation NotifySubscribers publishing Would generate two files:\napp/Services/Publishing/Operations/NotifySubscribersOperation.php tests/Unit/Services/Publishing/Operations/NotifySubscribersOperationTest.php The purpose of operation testing is to ensure that the integration between the jobs it runs is working as expected, but we do not have to test every job\u0026rsquo;s case on its own, for that we rely on jobs being tested for their integrity.\nFor example, consider the following operation test:\n\u0026lt;?php namespace Tests\\Unit\\Services\\Publishing\\Operations; use Tests\\TestCase; use App\\Data\\Models\\Author; use App\\Data\\Models\\Subscriber; use Illuminate\\Support\\Facades\\Queue; use App\\Services\\Operations\\NotifySubscribersOperation; class NotifySubscribersOperationTest extends TestCase { public function test_successfully_notifying_subscribers() { // SendNotificationJob will be dispatched to the queue Queue::fake(); // queue must be empty Queue::assertNothingPushed(); // n. of subscribers we\u0026#39;re testing with $subscribers = 10; $author = Author::factory() -\u0026gt;has(Subscriber::factory($subscribers)); -\u0026gt;create(); $op = new NotifySubscribersOperation($author-\u0026gt;id); $result = $op-\u0026gt;handle(); // assert all subscribers were paginated $this-\u0026gt;assertEquals($subscribers, $result); // assert the correct n. of SendNotificationJob were dispatched Queue::assertPushed(SendNotificationJob::class, $subscribers); } } Mocking Jobs When testing, you may occasionally need to skip dispatching a certain job but would still want to make sure that the operation actually ran the job as expected, with the correct parameters. In such cases we would mock the operation\u0026rsquo;s run partially.\nIn our case we\u0026rsquo;d update our test to not dispatch SendNotificationJob so that we don\u0026rsquo;t actually send notifications. This may seem odd at first because we are mocking the class that we are actually testing, but with partial mocks only the methods that we set expectations on would be mocked and the rest would be dispatched. And in case the operation doesn\u0026rsquo;t call run(SendNotificationJob::class, $params) with the expected parameters the test will fail.\n\u0026lt;?php namespace Tests\\Unit\\Services\\Publishing\\Operations; use Mockery; use Tests\\TestCase; use App\\Data\\Models\\Author; use App\\Data\\Models\\Subscriber; use App\\Services\\Operations\\NotifySubscribersOperation; class NotifySubscribersOperationTest extends TestCase { public function test_successfully_notifying_subscribers_with_mock() { // n. of subscribers we\u0026#39;re testing with $subscribers = 10; $author = Author::factory() -\u0026gt;has(Subscriber::factory($subscribers)); -\u0026gt;create(); // create operation mock instance $mOp = Mockery::mock(NotifySubscribersOperation::class, [$author-\u0026gt;id]); // set expectations to jobs that need to be skipped $mOp-\u0026gt;shouldReceive(\u0026#39;run\u0026#39;) -\u0026gt;with(SendNotificationJob::class, [ \u0026#39;from\u0026#39; =\u0026gt; $author, \u0026#39;to\u0026#39; =\u0026gt; $author-\u0026gt;subscribers, \u0026#39;notification\u0026#39; =\u0026gt; \u0026#39;article.published\u0026#39;, ]); $result = $mOp-\u0026gt;handle(); // assert all subscribers were paginated $this-\u0026gt;assertEquals($subscribers, $result); } } Whether to mock or not is a case-by-case decision, but as a general guideline it is best to always test with what\u0026rsquo;s closest to reality.\n"},{"uri":"https://docs.lucidarch.dev/services/","title":"Services","tags":[],"description":"","content":"Are the differentiating factors of Monolith. Their presence is necessary in multi-purpose projects that are set to scale in several areas of functionalities, a.k.a horizonal growth. They communicate with domains to compose jobs into groups of functionalities in their own features and operations.\nStructure Services are structured for scale, by adding an encapsulation layer for features, operations, routes, controllers, commands, resources (views) providers, tests and database; allowing our application to contain sections that differ in high degree and have plenty of those without causing clutter yet keep code navigation straight-forward.\nThe example below illustrates a comparison between a Lucid Monolith and a traditional directory separation in an application that has Chat, Product Management, Forum, Api and Admin listed with their features below:\nChat Send message Update message Delete message Share message Connect to channel Search messages Forum CRUD questions Manage questions in categories Schedule newsletter update Set answer as accepted Promote user as member Follow/unfollow question Search questions SEO Product Management CRUD product Add product to category Update product price Update product availability Search products Admin CRUD users CRUD organizations CRUD products CRUD projects Api CRUD application (like Slack \u0026amp; Facebook apps etc.) Send message Subscribe to product updates Subscribe to question updates An application this large will easily grow in files and directories to unmaintainable extents. To avoid that, we\u0026rsquo;ll create services for each to hold all their needs to function, which is exactly what\u0026rsquo;s initially in Laravel\u0026rsquo;s /app directory, in addition to tests.\napp/Services/Chat ├── Console │ └── Commands ├── Features ├── Operations ├── Http │ ├── Controllers │ └── Middleware ├── Providers │ ├── ChatServiceProvider.php │ ├── BroadcastServiceProvider.php │ └── RouteServiceProvider.php ├── Tests │ └── Features │ └── Operations ├── database │ ├── factories │ ├── migrations │ └── seeds ├── resources │ ├── lang │ └── views └── routes ├── api.php ├── channels.php ├── console.php └── web.php This is the initial structure of a service, however you may choose to customise it for what it needs only, for example if you prefer to have the database stuff at the root or that this service doesn\u0026rsquo;t have any database work to do on its own, you would simply remove it from within the service. Similar for Console and everything else.\nHere\u0026rsquo;s an illustrative comparison between the traditional and the services approaches in routing and controllers:\nRoutes Showcase Traditional\nUsing the traditional approach where all of our routes are in routes/web.php, we\u0026rsquo;ll find that this file will keep growing the more functionalities we add. Also, if more than a single person is working on it, it is highly likely to produce conflicts on merge which is always an unpleasant experience.\nExpand file locations to see their code.\nroutes/web.php routes/api.php Of course there are ways to separate routes into several files and load them in the service provider, but routing isn\u0026rsquo;t the only problem that we will be facing, it is just a part of it.\nLucid Service Routes Showcase\nOn the other hand, with services we\u0026rsquo;ve separated these routes files where they belong to have a pleasant experience working with them and avoid conflicts as a team.\napp/Services/Chat/routes/web.php Route::middleware([\u0026#39;auth\u0026#39;, \u0026#39;subscription\u0026#39;])-\u0026gt;group(\u0026#39;chat\u0026#39;, function() { Route::post(\u0026#39;/messages\u0026#39;, [ChatController::class, \u0026#39;sendMessage\u0026#39;]); Route::put(\u0026#39;/messages/{id}\u0026#39;, [ChatController::class, \u0026#39;updateMessage\u0026#39;]); Route::post(\u0026#39;/messages/{id}/share\u0026#39;, [ChatController::class, \u0026#39;shareMessage\u0026#39;]); Route::post(\u0026#39;/channels/{channel}/connect\u0026#39;, [ChatController::class, \u0026#39;connect\u0026#39;]); Route::post(\u0026#39;/search\u0026#39;, [ChatController::class, \u0026#39;search\u0026#39;]); }); app/Services/Forum/routes/web.php Route::middleware([\u0026#39;auth\u0026#39;, \u0026#39;subscription\u0026#39;])-\u0026gt;group(\u0026#39;forum\u0026#39;, function() { Route::get(\u0026#39;/questions\u0026#39;, [ForumController::class, \u0026#39;questions\u0026#39;]); Route::post(\u0026#39;/questions\u0026#39;, [ForumController::class, \u0026#39;addQuestion\u0026#39;]); Route::put(\u0026#39;/questions/{id}\u0026#39;, [ForumController::class, \u0026#39;updateQuestion\u0026#39;]); Route::delete(\u0026#39;/questions/{id}\u0026#39;, [ForumController::class, \u0026#39;deleteQuestion\u0026#39;]); Route::put(\u0026#39;/questions/{id}/category\u0026#39;, [ForumController::class, \u0026#39;category\u0026#39;]); Route::put(\u0026#39;/questions/{id}/accept\u0026#39;, [ForumController::class, \u0026#39;accept\u0026#39;]); Route::post(\u0026#39;/questions/{id}/follow\u0026#39;, [ForumUserController::class, \u0026#39;follow\u0026#39;]); Route::get(\u0026#39;/questions/search\u0026#39;, [ForumUserController::class, \u0026#39;search\u0026#39;]); Route::put(\u0026#39;/users/{id}/promote\u0026#39;, [ForumUserController::class, \u0026#39;promote\u0026#39;]); }); app/Services/Products/routes/web.php Route::middleware([\u0026#39;auth\u0026#39;, \u0026#39;subscription\u0026#39;])-\u0026gt;group(\u0026#39;products\u0026#39;, function() { Route::get(\u0026#39;/search\u0026#39;, [ProductController::class, \u0026#39;search\u0026#39;]); Route::get(\u0026#39;/\u0026#39;, [ProductController::class, \u0026#39;get\u0026#39;]); Route::get(\u0026#39;/{id}\u0026#39;, [ProductController::class, \u0026#39;show\u0026#39;]); Route::post(\u0026#39;/\u0026#39;, [ProductController::class, \u0026#39;add\u0026#39;]); Route::put(\u0026#39;/{id}\u0026#39;, [ProductController::class, \u0026#39;update\u0026#39;]); Route::delete(\u0026#39;/{id}\u0026#39;, [ProductController::class, \u0026#39;delete\u0026#39;]); Route::put(\u0026#39;/{id}/category\u0026#39;, [ProductController::class, \u0026#39;category\u0026#39;]); Route::put(\u0026#39;/{id}/price\u0026#39;, [ProductController::class, \u0026#39;price\u0026#39;]); Route::put(\u0026#39;/{id}/stock\u0026#39;, [ProductController::class, \u0026#39;stock\u0026#39;]); }); app/Services/Api/routes/api.php Route::middleware([\u0026#39;throttle:api\u0026#39;])-\u0026gt;group(\u0026#39;api\u0026#39;, function () { Route::get(\u0026#39;/apps/search\u0026#39;, [AppController::class, \u0026#39;search\u0026#39;]); Route::get(\u0026#39;/apps\u0026#39;, [AppController::class, \u0026#39;get\u0026#39;]); Route::get(\u0026#39;/apps/{id}\u0026#39;, [AppController::class, \u0026#39;show\u0026#39;]); Route::post(\u0026#39;/apps\u0026#39;, [AppController::class, \u0026#39;add\u0026#39;]); Route::put(\u0026#39;/apps/{id}\u0026#39;, [AppController::class, \u0026#39;update\u0026#39;]); Route::delete(\u0026#39;/apps/{id}\u0026#39;, [AppController::class, \u0026#39;delete\u0026#39;]); Route::post(\u0026#39;/channels/{id}\u0026#39;, [ChatController::class, \u0026#39;subscribe\u0026#39;]); Route::post(\u0026#39;/products/{id}\u0026#39;, [ProductController::class, \u0026#39;subscribe\u0026#39;]); Route::post(\u0026#39;/questions/{id}\u0026#39;, [ForumController::class, \u0026#39;subscribe\u0026#39;]); }); app/Services/Admin/routes/web.php Another variation of routes would be to reduce Admin routes by including them in their corresponding services instead of having Admin service include them all. Both approaches have their benefits so you may choose whichever works best for your case.\napp/Services/Products/routes/web.php Controllers Showcase Consolidating routes and controllers in services allows us to have them side-by-side within the same context, so that we don\u0026rsquo;t have to go digging for code in foreign directories.\nTraditional\napp/Http/Controllers ├── Admin │ ├── ProductController.php │ ├── ForumController.php │ ├── UserController.php │ └── OrganizationController.php ├── Api │ ├── AppController.php │ ├── ChatController.php │ └── HookController.php ├── Chat │ └── MessageController.php ├── Products │ └── ProductController.php └── Forum ├── QuestionController.php ├── CategoryController.php └── MemberController.php Lucid Service Controllers\napp/Services/Admin/Http/Controllers ├── ProductController.php ├── ForumController.php ├── UserController.php └── OrganizationController.php app/Services/Api/Http/Controllers ├── AppController.php ├── ChatController.php └── HookController.php app/Services/Chat/Http/Controllers └── MessageController.php app/Services/ProductManagement/Http/Controllers └── ProductController.php app/Services/Forum/Http/Controllers ├── QuestionController.php ├── MemberController.php └── CategoryController.php Benefits Concentration Working on a feature in a service wouldn\u0026rsquo;t concern you with others outside the bounds of said service.\nEfficiency Reduced code review time and merge conflicts when working with a team, due to the separation of concerns.\nSeparation Consider having Single Responsibility and Separation of Concerns, not only at the code level, but also in the structure.\nRemember that it is completely optional to use Services. In fact there is no obligation whatsoever with Lucid, pick any unit from the stack and use it to your convenience; just preserve Lucid\u0026rsquo;s guidelines as you do.\nCreate a Service lucid make:service Chat This will generate the directory structure for a service in app/Services/Chat/*\napp/Services/Chat ├── Console │ └── Commands ├── Features ├── Operations ├── Http │ ├── Controllers │ └── Middleware ├── Providers │ ├── ChatServiceProvider.php │ ├── BroadcastServiceProvider.php │ └── RouteServiceProvider.php ├── Tests │ └── Features │ └── Operations ├── database │ ├── factories │ ├── migrations │ └── seeds ├── resources │ ├── lang │ └── views └── routes ├── api.php ├── channels.php ├── console.php └── web.php Register Service Once created we\u0026rsquo;ll need to tell Laravel about our service so that it loads its files such as routes, migrations, views and others. There are two ways to register the service\u0026rsquo;s provider, in this case it\u0026rsquo;s ChatServiceProvider:\n1. In Configuration: config/app.php\nAdd App\\Services\\Chat\\Providers\\ChatServiceProvider::class to 'providers' in config/app.php\nThis will register and load the service every time the application launches.\n2. In AppServiceProvider::register\n\u0026lt;?php namespace App\\Providers; use Illuminate\\Support\\ServiceProvider; use App\\Services\\Api\\Providers\\ApiServiceProvider; class AppServiceProvider extends ServiceProvider { /** * Register any application services. * * @return void */ public function register() { $this-\u0026gt;app-\u0026gt;register(ApiServiceProvider::class); } } This opens up possibilities for conditional registration of services. For example you may choose to load Dashboard service only when in the local environment:\npublic function register() { if (App::environment(\u0026#39;local\u0026#39;)) { $this-\u0026gt;app-\u0026gt;register(DashboardServiceProvider::class); } } Run Service Tests Initially service tests are part of the default testsuite, but in case you wish to run a single service\u0026rsquo;s tests in isolation please add the following to your phpunit.xml under \u0026lt;testsuites\u0026gt; (must be done for each service), and then we would be able to use phpunit --testsuite \u0026lt;name\u0026gt; to run them.\n\u0026lt;testsuite name=\u0026#34;Chat\u0026#34;\u0026gt; \u0026lt;directory suffix=\u0026#34;Test.php\u0026#34;\u0026gt;./tests/Feature/Services/Chat\u0026lt;/directory\u0026gt; \u0026lt;directory suffix=\u0026#34;Test.php\u0026#34;\u0026gt;./tests/Unit/Services/Chat\u0026lt;/directory\u0026gt; \u0026lt;/testsuite\u0026gt; Now we can run the tests for this service in isolation:\nphpunit --testsuite Chat Working with Services All unit generation commands (lucid make:*) have an optional parameter \u0026lt;service\u0026gt; to specify which service you\u0026rsquo;d like to generate the unit into.\ncommand parameters are case-insensitive, Lucid will try to convert to the corresponding case.\nControllers Signature lucid make:controller \u0026lt;controller\u0026gt; \u0026lt;service\u0026gt;\nExample\nlucid make:controller message chat Will generate app/Services/Chat/Http/Controllers/MessageController.php\n\u0026lt;?php namespace App\\Services\\Chat\\Http\\Controllers; use Lucid\\Units\\Controller; class MessageController extends Controller { } Features Signature lucid make:feature \u0026lt;feature\u0026gt; \u0026lt;service\u0026gt;\nExample\nlucid make:feature SendMessage chat Will generate app/Services/Chat/Features/SendMessageFeature.php\n\u0026lt;?php namespace App\\Services\\Chat\\Features; use Lucid\\Units\\Feature; use Illuminate\\Http\\Request; class SendMessageFeature extends Feature { public function handle(Request $request) { } } Operations Signature lucid make:operation \u0026lt;operation\u0026gt; \u0026lt;service\u0026gt;\nExample\nlucid make:operation EnqueueMessageForSending chat Will generate app/Services/Chat/Operations/EnqueueMessageForSendingOperation.php\n\u0026lt;?php namespace App\\Services\\Chat\\Operations; use Lucid\\Units\\Operation; class EnqueueMessageForSendingOperation extends Operation { /** * Create a new operation instance. * * @return void */ public function __construct() { // } /** * Execute the operation. * * @return void */ public function handle() { } } Migrations When generated, migrations are automatically registered in the global application\u0026rsquo;s migrations so Laravel knows about them and running them can be done simply by using php arisan migrate. This is done in the Service\u0026rsquo;s service provider class (in our example it\u0026rsquo;s ChatServiceProvider) that we added to our app\u0026rsquo;s providers upon creation.\nGenerate Migration Signature lucid make:migration \u0026lt;migration\u0026gt; \u0026lt;service\u0026gt;\nExample\nlucid make:migration create_messages_table chat Will generate app/Services/Chat/database/migrations/{date}_create_messages_table.php\n\u0026lt;?php use Illuminate\\Database\\Migrations\\Migration; use Illuminate\\Database\\Schema\\Blueprint; use Illuminate\\Support\\Facades\\Schema; class CreateMessagesTable extends Migration { /** * Run the migrations. * * @return void */ public function up() { Schema::create(\u0026#39;messages\u0026#39;, function (Blueprint $table) { $table-\u0026gt;id(); $table-\u0026gt;timestamps(); }); } /** * Reverse the migrations. * * @return void */ public function down() { Schema::dropIfExists(\u0026#39;messages\u0026#39;); } } Run Service Migrations Our migrations are recognized by Laravel due to them being loaded automatically in the service provider - ChatServiceProvider in this example.\nWhich makes it straight-forward to run them:\nphp artisan migrate Removing Migrations In the case where your service doesn\u0026rsquo;t use any of the database functionalities and you\u0026rsquo;d like to tidy up by deleting the database folder, make sure you remove the following from the service provider - typically at app/Services/{name}/Providers/{name}ServiceProvider.php\npublic function boot() { $this-\u0026gt;loadMigrationsFrom([ realpath(__DIR__ . \u0026#39;/../database/migrations\u0026#39;) ]); } Lang \u0026amp; Views Each service is provided with its own resources directory that resembles Laravel\u0026rsquo;s, containing views and lang. All the files that are created there will be registered under a namespace named in snake_case after the service\u0026rsquo;s name.\nThis is initially done in the Service Provider upon creating the service, for example in ChatServiceProvider::registerResources:\nprotected function registerResources() { // Translation must be registered ahead of adding lang namespaces $this-\u0026gt;app-\u0026gt;register(TranslationServiceProvider::class); Lang::addNamespace(\u0026#39;chat\u0026#39;, realpath(__DIR__.\u0026#39;/../resources/lang\u0026#39;)); View::addNamespace(\u0026#39;chat\u0026#39;, base_path(\u0026#39;resources/views/vendor/chat\u0026#39;)); View::addNamespace(\u0026#39;chat\u0026#39;, realpath(__DIR__.\u0026#39;/../resources/views\u0026#39;)); } To use these views simply prepend them with their corresponding namespace {namespace}::{view}.\nRoute::get(\u0026#39;/chat\u0026#39;, function() { return view(\u0026#39;chat::welcome\u0026#39;); }); For multi-word services such as ProductManagement it will be product_management::welcome.\nIf your service doesn\u0026rsquo;t use views and you\u0026rsquo;d like to de-clutter, feel free to remove the resources folder altogether and remember to remove registerResources method from the service provider as well as its call in register.\nTests Testing services is about testing their features and operations, they\u0026rsquo;re scoped according to the type of test:\nFeature: tests/Feature/Services/{service}/{Feature}Test.php Operation: tests/Unit/Services/{service}/{Operation}Test.php Other tests that belong to the service can be placed in correspondance to the above.\nIt is also recommended to namespace your test classes just to avoid conflicts. This is done by default for features and operations that are generated using lucid make:* following PSR-4 standard. An initial test could look like this:\n\u0026lt;?php namespace Tests\\Feature\\Services\\Chat; use Tests\\TestCase; use App\\Services\\Chat\\Features\\SendMessageFeature; class SendMessageFeatureTest extends TestCase { public function test_sendmessagefeature() { $this-\u0026gt;markTestIncomplete(); } } Providers Service providers are the connecting wires between the Lucid stack and Laravel especially when it comes to services, they are used to tell Laravel where our code is and what to load, from where, and when.\nEach service comes with its own set of providers in app/Services/{service}/Providers and most essentially the service\u0026rsquo;s own provider that is usually named after the service e.g. ChatServiceProvider or ProductManagementServiceProvider.\nFor Laravel to know about our service and load its files such as database migrations, lang, views and any other classes and elements you would like to register in that service specifically, the service provider must be part of providers in config/app.php\n\u0026#39;providers\u0026#39; =\u0026gt; [ ... App\\Services\\Api\\Providers\\ApiServiceProvider::class, App\\Services\\Chat\\Providers\\ChatServiceProvider::class, App\\Services\\ProductManagement\\Providers\\ProductManagementServiceProvider::class, ] Custom Service Provider We can create and register our own providers which allows us to segregate functionality further within our services:\napp/Services/Chat/Providers/RiakServiceProvider\n\u0026lt;?php namespace App\\Services\\Chat\\Providers; use Riak\\Connection; use Illuminate\\Support\\ServiceProvider; class RiakServiceProvider extends ServiceProvider { /** * Register any application services. * * @return void */ public function register() { $this-\u0026gt;app-\u0026gt;singleton(Connection::class, function ($app) { return new Connection(config(\u0026#39;riak\u0026#39;)); }); } } Then register RiakServiceProvider in the service\u0026rsquo;s provider to be automatically loaded whenever the service\u0026rsquo;s provider is loadeo:\napp/Services/Chat/Providers/ChatServiceProvider\npublic function regsiter() { $this-\u0026gt;app-\u0026gt;register(RiakServiceProvider::class); } A Note On Microservices Talking about projects at scale may often lead us to talk about Microservices. Turning your Monolith services into several instances of their own is one of the ways you may benefit from using services in a Monolith since each resembles a Laravel project, and naturally in microservies we\u0026rsquo;d create a separate Laravel installation for each microservice, our Lucid services are ready for that due to the correspondence in structure; nevertheless it would still require considerable effort to make the move but it is reduced significantly with this in hand, especially that there will be much more to consider in the transformation.\nThis is likely to occur in a number of projects but certainly not all of them.\nIn Lucid terms: each of the services will become a Micro instance, preserving features \u0026amp; operations with their entrypoints and their tests. What will be left as a dependency is domains and data which can be created in a package and shared among the microservices that require it. Even though you may wish to also have proprietary domains in the services themselves which will be possible to do as well.\nVisit \u0026ldquo;Micro vs. Monolith\u0026rdquo; for more.\nSOA \u0026amp; Lucid When the word \u0026ldquo;services\u0026rdquo; is mentinoed it is invevitable to drift in thought towards Service-Orienter Architecture, where controllers call a method from a \u0026ldquo;service\u0026rdquo; class that performs the work required. In most cases where this structure is used, it was found that eventually services became the new controllers - large and full of unmaintainable logic. In addition to the difficulty in sharing code between services due to the tight coupling with other components.\nFor that reason, Lucid services take it up a level to give the service a structure that allows it to grow, by organize its code according to a familiar structure and expose its functionalities.\nAre Lucid Services Complient to SOA? In brief, yes. However, there\u0026rsquo;s a difference in the hierarchy:\nIn SOA, the application layer is at the top, it includes the services that are needed and the application registers and handles the routing, controller and directs the requests to the service\u0026rsquo;s entrypoint. Lucid Services on the other hand give that power to the service so that it implements all that is required from routes, controllers, and the rest, and the application will only register the service. This approach has proven to be efficient at scale due to the degree of separation, specifically with team collaboration, interoperability and integrity. "},{"uri":"https://docs.lucidarch.dev/domains/","title":"Domains","tags":[],"description":"","content":"Inspired by Domain-Driven Development, this piece of the Lucid stack is merely directories that are all about organizing and categorizing code according to the topic they belong to.\nThere is no specific way of naming them because it differs per case, but according to our experience over the years we found that they\u0026rsquo;re usually of two types, the \u0026ldquo;internal\u0026rdquo; and the \u0026ldquo;external\u0026rdquo; type of domain. Here are a few examples to illustrate the difference\nInternal\nHttp RespondWithJsonJob RespondWithJsonErrorJob RespondWithHtmlJob RespondWithHtmlErrorJob RespondWithViewJob Chat SendMessageToChannelJob External\nGitHub LoginWithGitHubJob FetchGitHubReposJob Facebook LoginWithFacebookJob FetchUserPostsJob Even though they differ in the nature of functionalities they expose, these are still domains from which our application would (re)use code wherever possible. This separation is only logical to help with the understanding of domains but is not an actual separation in code.\nCharacteristics Isolation: Domains operate in isolation in the sense that they should never need anything from another domain to accomplish their job. They may, however, use elements from the framework or Foundation for abstraction reasons and to eliminate code replication. Encapsulation: Ideally, domains should be structured in a way that would allow them to be moved around with the least amount of impact on their output. They contain their jobs, requests/validation, tests and other custom classes to get their job done. Consider domain jobs to be the pieces of code that will be shared and reused the most, they can be called from anywhere which makes it essential that they do not depend on any other domain.\nWhat Goes Into A Domain From the Lucid stack, domains contain Job classes and their tests, acting as the only way of communicating with a domain. However any other class that belongs to the domain should also be present there for centralisation.\nConsider the example of an application that integrates with GitHub to login as a GitHub user and it allows to fetch a repository\u0026rsquo;s info from GitHub\u0026rsquo;s API:\napp/Domains/GitHub ├── GitHubClient.php ├── Jobs │ ├── FetchGitHubRepoInfoJob.php │ └── LoginWithGitHubJob.php ├── Exceptions │ ├── InvalidTokenException.php │ └── RepositoryNotFoundException.php └── Tests └── GitHubClientTest.php └── Jobs ├── FetchGitHubReposJobTest.php └── LoginWithGitHubJobTest.php GitHubClient is the class that the jobs use to communicate with GitHub\u0026rsquo;s API. FetchGitHubRepoInfoJob contains all the details required to call the API such as URL and query params, exposing them through parameters in the signature, and using the rest of the classes from the domain: This code snippet is fictional, it is for demonstrative purposes only and is not meant to work as-is in real life.\n\u0026lt;?php namespace App\\Domains\\GitHub\\Jobs; use Lucid\\Units\\Job; use App\\Domains\\GitHub\\GitHubClient; use App\\Domains\\GitHub\\Exceptions\\InvalidTokenException; use App\\Domains\\GitHub\\Exceptions\\RepositoryNotFoundException; class FetchGitHubRepoInfoJob extends Job { private $name; private $includeCollaborators; public function __construct($name, $includeCollaborators = false) { $this-\u0026gt;name = $name; $this-\u0026gt;includeCollaborators = $includeCollaborators; } public function handle(GitHubClient $github) { $params = []; if ($this-\u0026gt;includeCollaborators) { $params = \u0026#39;with_collaborators\u0026#39;; } $response = $github-\u0026gt;repo($this-\u0026gt;name, $params); switch($response-\u0026gt;status) { case 404: throw new RepositoryNotFoundException(); break; case 403: throw new InvalidTokenException(); break; } return $response; } } Testing Domains contain the tests of their jobs and classes in order to be self-sufficient. They are considered to be unit tests so that the domain can provide the guarantee of a working unit, that way we focus on feature tests in the rest of the application.\nWhen generating Jobs, their tests are automatically generated in the corresponding locations:\nlucid make:job FetchGitHubRepoInfoJob GitHub Will generate two files:\napp/Domains/GitHub/Jobs/FetchGitHubRepoInfoJob.php tests/Unit/Domains/GitHub/Jobs/FetchGitHubRepoInfoJobTest.php "},{"uri":"https://docs.lucidarch.dev/testing/","title":"Testing","tags":[],"description":"","content":"Mocking Units Lucid takes testing very seriously, thus it tries to make it extremely simple to simulate use cases with very little coding.\nEvery Lucid unit in the stack can be mocked by calling mock([$args])-\u0026gt;should*() to make it easier to be replaced with a mock version of itself.\nGetUserByIDJob::mock([\u0026#39;id\u0026#39; =\u0026gt; $id])-\u0026gt;shouldReturn($user); This will replace any call to GetUserByIDJob with the corresponding parameters with this instance and return the given $user, as long as the passed arguments matches the unit\u0026rsquo;s constructor signature, as well as the calling method\n$this-\u0026gt;run(new GetUserByIDJob(id: $id)); otherwise an exception will be thrown for not finding a perfect match. For example, the following will certainly not pass the tests:\n$this-\u0026gt;run(new GetUserByIDJob(notid: $id)); The purpose of testing units is to make sure that whoever calls them is passing the right parameters and will be aware of their signature changes, in which case tests shall fail.\nFor example, if GetUserByIDJob were to change signature and add another parameter, which ever test uses its mock shall fail:\nclass GetUserByIDJob { public function __construct($id, $isFlat) { ... } } Now our previous mock will certainly cause a failure since it\u0026rsquo;s not matching the constructor args, and thus achieve a reliable suite of tests.\nGetUserByIDJob::mock([\u0026#39;id\u0026#39; =\u0026gt; $id])-\u0026gt;shouldReturn($user); // fail! Expectation Types Creating a mock by calling mock() on a unit alone wouldn\u0026rsquo;t suffice, there needs to be an expectation in order for the mock to be registered.\nSince testing and mocking is all about simulating expectations, here are the methods you can use to set them.\nshouldBeDispatched shouldBeDispatched(): void This method is used when we expect the unit to be dispatched but we\u0026rsquo;re not waiting for any output.\nExample\n$this-\u0026gt;run(new InviteMemberJob(memberId: $memberId)); InviteMemberJob::mock([\u0026#39;memberId\u0026#39; =\u0026gt; \u0026#39;some-member\u0026#39;])-\u0026gt;shouldBeDispatched(); shouldReturn shouldReturn($value): mixed This method is used to return any value that will be expected upon the unit\u0026rsquo;s execution.\nExample\n$repos = $this-\u0026gt;run(new FetchGitHubReposOperation(username: $username)); $repos = collect(GitHubRepository::factory()-\u0026gt;make(5)); FetchGitHubReposOperation::mock([\u0026#39;username\u0026#39; =\u0026gt; $username])-\u0026gt;shouldReturn($repos); shouldThrow shouldThrow($exception, $message = '', $code = 0, Exception $previous = null): void\nThis method simulates a unit throwing an exception.\nExample\n$this-\u0026gt;run(new AddPostJob(title: $title, content: $content)); AddPostJob::mock([\u0026#39;title\u0026#39; =\u0026gt; $title, \u0026#39;content\u0026#39; =\u0026gt; $content]) -\u0026gt;shouldThrow(new NotLoggedInException(), \u0026#39;you must be logged in to add a post\u0026#39;, 401)) shouldReturn[Bool] shouldReturnTrue(): true \u0026amp; shouldReturnFalse(): false The use of these methods is as obvious, to return the corresponding boolean.\nExample\n$authorized = $this-\u0026gt;run(new CheckUserAuthorizationJob(user: $user)); CheckUserAuthorizationJob::mock([\u0026#39;user\u0026#39; =\u0026gt; $user])-\u0026gt;shouldReturnTrue(); // authorized CheckUserAuthorizationJob::mock([\u0026#39;user\u0026#39; =\u0026gt; $user])-\u0026gt;shouldReturnFalse(); // not authorized Testing Features Upon generating a feature, a test file would\u0026rsquo;ve already been generated with it in the same name. Feature tests reside at tests/Feature/* in compliance with Laravel\u0026rsquo;s directory structure.\nWhen testing features we\u0026rsquo;re interested in the sequence of executions that happen in the feature\u0026rsquo;s handle method, and in making sure that the right units (jobs and operations) are being called with the correct arguments. To achieve that we\u0026rsquo;d have to mock some calls and execute the ones we can.\nLucid makes it extremely easy to mock and set expectations to replace the units you need.\nConsider a feature to create a channel in a chat application; the following steps need to be taken in order to successfully create one:\nFetch the member\u0026rsquo;s object by ID Make sure the user is authorized to create a channel Create channel Add the user to the channel Invite members to join the channel as well Here\u0026rsquo;s how that might look like in code (simplified):\nclass CreateChannelFeature extends Feature { public function handle(CreateChannelRequest $request) { $member = $this-\u0026gt;run(new GetMemberByIdJob($request-\u0026gt;input(\u0026#39;id\u0026#39;))); $authorized = $this-\u0026gt;run(new AuthorizeMemberActionJob( action: Action::CREATE_CHANNEL, )); if (!$authorized) { throw new UnauthorizedActionException(); } $channel = $this-\u0026gt;run(new CreateChannelJob($request-\u0026gt;input(\u0026#39;title\u0026#39;))); $this-\u0026gt;run(new AddMemberToChannelJob( member: $member, channel: $channel, )); $this-\u0026gt;run(new InviteMembersToChannelOperation( channel: $channel, members: $request-\u0026gt;input(\u0026#39;invited\u0026#39;), )); } } When testing that feature class, we will use Lucid\u0026rsquo;s unit mocking techniques to turn some knobs around and simulate our test cases. Here are a few examples:\nTest Unauthorized Member\nTo simulate an unauthorized user we\u0026rsquo;d need to mock AuthorizeMemberActionJob and return false so that it throws the corresponding exception.\npublic function test_create_organization_unauthorized_member() { $member = Member::factory()-\u0026gt;make(); AuthorizeMemberActionJob::mock([\u0026#39;action\u0026#39; =\u0026gt; Action::CREATE_CHANNEL]) -\u0026gt;shouldReturnFalse(); $this-\u0026gt;expectException(UnauthorizedActionException::class); $this-\u0026gt;postJson(\u0026#39;/channels\u0026#39;, [ \u0026#39;id\u0026#39; =\u0026gt; $member-\u0026gt;id, \u0026#39;title\u0026#39; =\u0026gt; \u0026#39;ping-channel\u0026#39;, \u0026#39;invited\u0026#39; =\u0026gt; [\u0026#39;member-id-1\u0026#39;, \u0026#39;member-id-2\u0026#39;] ]); } Simulate an Invitation Error\nTo see how our code will behave when an issue occurs as we invite other members, let\u0026rsquo;s cause it to happen.\npublic function test_create_organization_invitation_error() { $member = Member::factory()-\u0026gt;make(); $channel = Channel::factory()-\u0026gt;make(); AuthorizeMemberActionJob::mock([\u0026#39;action\u0026#39; =\u0026gt; Action::CREATE_CHANNEL]) -\u0026gt;shouldReturnTrue(); // we will need this to be pass it to the following operation CreateChannelJob::mock([\u0026#39;title\u0026#39; =\u0026gt; $channel-\u0026gt;title]) -\u0026gt;shouldReturn($channel); InviteMembersToChannelOperation::mock([ \u0026#39;channel\u0026#39; =\u0026gt; $channel, \u0026#39;members\u0026#39; =\u0026gt; [\u0026#39;member-id-1\u0026#39;, \u0026#39;member-id-2\u0026#39;] ])-\u0026gt;shouldThrow(new DatabaseConnectionException(), \u0026#39;could not connect to database\u0026#39;, 500); $this-\u0026gt;postJson(\u0026#39;/channels\u0026#39;, [ \u0026#39;id\u0026#39; =\u0026gt; $member-\u0026gt;id, \u0026#39;title\u0026#39; =\u0026gt; $channel-\u0026gt;title, \u0026#39;invited\u0026#39; =\u0026gt; [\u0026#39;member-id-1\u0026#39;, \u0026#39;member-id-2\u0026#39;] ]); } About Testing and Databases It is recommended that Feature tests cover the entire set of functionalities, including storage, however unit tests that cover Jobs and Operations should be left for preference, though make sure you are consistent across your codebase.\nNevertheless, sometimes we may choose to not hit the DB. Mocking can help with that since it will replace the unit (job/operation) with its mock so when executing its code won\u0026rsquo;t run. It is extremely important, however, to ensure that the job being mocked has tests of its own, extensively, otherwise we\u0026rsquo;ll be leaving loose ends and may face unanticipated outcomes.\n"},{"uri":"https://docs.lucidarch.dev/database/","title":"Database","tags":[],"description":"","content":"Migrations Micro migrations: Are the Laravel built-in migrations so please refer to the official docs and the artisan migrate:* commands.\nService migrations: When a service is generated with the lucid make:service command, it will contain a database directory that resemble /database at root.\napp/Services/Chat/database ├── factories ├── migrations └── seeders The examples in this document assume that our service name is Chat, please make sure to replace it with your service name instead.\nGenerate Service Migration Signature lucid make:migration \u0026lt;migration\u0026gt; \u0026lt;service\u0026gt;\nExample\nlucid make:migration create_messages_table chat Will generate app/Services/Chat/database/migrations/{date}_create_messages_table.php\n\u0026lt;?php use Illuminate\\Database\\Migrations\\Migration; use Illuminate\\Database\\Schema\\Blueprint; use Illuminate\\Support\\Facades\\Schema; class CreateMessagesTable extends Migration { /** * Run the migrations. * * @return void */ public function up() { Schema::create(\u0026#39;messages\u0026#39;, function (Blueprint $table) { $table-\u0026gt;id(); $table-\u0026gt;timestamps(); }); } /** * Reverse the migrations. * * @return void */ public function down() { Schema::dropIfExists(\u0026#39;messages\u0026#39;); } } Run Service Migrations Our migrations are recognized by Laravel due to them being loaded automatically in the service provider - ChatServiceProvider in this example.\nWhich makes it straight-forward to run them:\nphp artisan migrate Disable Service Migrations If your service doesn\u0026rsquo;t use a [separate] database (you may always still use Laravel\u0026rsquo;s default migrations) and you wish to clean it up from database stuff:\nRemove app/Services/Chat/database directory Remove the following snippet from ChatServiceProvider::boot in app/Services/Chat/Providers/ChatServiceProvider.php $this-\u0026gt;loadMigrationsFrom([ realpath(__DIR__ . \u0026#39;/../database/migrations\u0026#39;) ]); Factories Register service factories in composer\nUnder autoload.psr-4 add \u0026quot;App\\\\Services\\\\Chat\\\\Database\\\\Factories\\\\\u0026quot;: \u0026quot;app/Services/Chat/database/factories/\u0026quot;\nSo your composer.json should have a similar section as this:\n{ \u0026#34;autoload\u0026#34;: { \u0026#34;psr-4\u0026#34;: { \u0026#34;App\\\\\u0026#34;: \u0026#34;app/\u0026#34;, \u0026#34;Database\\\\Factories\\\\\u0026#34;: \u0026#34;database/factories/\u0026#34;, \u0026#34;Database\\\\Seeders\\\\\u0026#34;: \u0026#34;database/seeders/\u0026#34;, \u0026#34;App\\\\Services\\\\Chat\\\\Database\\\\Factories\\\\\u0026#34;: \u0026#34;app/Services/Chat/database/factories/\u0026#34; } } } Run composer dump-autoload Create factory class (e.g. php artisan make:factory --model=Message)\nMove factory class from /database/factories to /app/Services/Chat/database/factories\nChange class namespace to App\\Services\\Chat\\Database\\Factories\nIn your model class (here it\u0026rsquo;s Message): add newFactory() method. This is a method override that Laravel natively looks at before loading the default factory (see HasFactory trait)\nuse App\\Services\\Chat\\Database\\Factories\\MessageFactory; protected static function newFactory() { return app(MessageFactory::class); } Use the factory from the model as you would by default: Message::factory()-\u0026gt;make()\nSeeders Register service seeders in composer\nUnder autoload.psr-4 add the following \u0026quot;App\\\\Services\\\\Chat\\\\Database\\\\Seeders\\\\\u0026quot;: \u0026quot;app/Services/Chat/database/seeders/\u0026quot;\nSo your composer.json should have a similar section as this:\n{ \u0026#34;autoload\u0026#34;: { \u0026#34;psr-4\u0026#34;: { \u0026#34;App\\\\\u0026#34;: \u0026#34;app/\u0026#34;, \u0026#34;Database\\\\Factories\\\\\u0026#34;: \u0026#34;database/factories/\u0026#34;, \u0026#34;Database\\\\Seeders\\\\\u0026#34;: \u0026#34;database/seeders/\u0026#34;, \u0026#34;App\\\\Services\\\\Chat\\\\Database\\\\Seeders\\\\\u0026#34;: \u0026#34;app/Services/Chat/database/seeders/\u0026#34; } }, } Run composer dump-autoload Create seeder class (e.g. php artisan make:seeder MessageSeeder)\nMove seeder class from /database/seeders to /app/Services/Chat/database/seeders\nChange class namespace to App\\Services\\Chat\\Database\\Seeders\nCall MessageSeeder::class from /database/seeders/DatabaseSeeder.php\nuse App\\Services\\Chat\\Database\\Seeders\\MessageSeeder; public function run() { $this-\u0026gt;call([ MessageSeeder::class, ]); } Seed the database with php artisan db:seed\n"},{"uri":"https://docs.lucidarch.dev/validation/","title":"Validation","tags":[],"description":"","content":"As common as it is, validation is essential for every application. Lucid brings a domain-driven approach that embraces Laravel\u0026rsquo;s validation. In short, if you\u0026rsquo;ve done validation with Laravel you\u0026rsquo;re already familiar with everything here, we will only choose convenient locations for Validators and Form Requests by placing them in domains.\nDomain-Driven Validation Often times validation is a matter of context, and domains in Lucid are an ideal place to encapsulate functionality, and form requests fit perfectly there! e.g. Domains/{domain}/Requests/{Request}.php\nEventually we\u0026rsquo;d end up with a categorical directory structure that protects our validation files from becoming unmanageable.\nForm Requests\napp/Domains ├── Chat │ └── Requests │ └── SendMessage.php ├── Comment │ └── Requests │ └── AddComment.php ├── Filesystem │ └── Requests │ └── UploadFiles.php └── Post └── Requests ├── CreatePost.php └── UpdatePost.php Validation Jobs\napp/Domains ├── Chat │ └── Jobs │ └── ValidateNewMessageJob.php ├── Comment │ └── Jobs │ └── ValidateNewCommentJob.php ├── Filesystem │ └── Jobs │ └── ValidateFilesUploadJob.php └── Post └── Jobs ├── ValidateNewPostJob.php └── ValidatePostUpdateJob.php Form Request Validation In an effort to keep our controllers thin and reduce their clutter, as well as having features carry their requirements with them wherever we decide to serve them from, it is recommended for validation using Form Request to happen in features instead of controllers, to maintain their integrity whenever they\u0026rsquo;re served.\nNevertheless, it is done exactly the same as Laravel controllers in any of Lucid\u0026rsquo;s units, by injecting the form request class in the method signature as a parameter:\nclass CustomFeature extends Feature { public function handle(UpdatePost $request) { // request is valid according to the rules specified in UpdatePost } } This will perform Form Request Validation using UpdatePost class.\nThe same can be done in any unit: Feature, Job and Operation.\nFor more on Form Request classes see Laravel\u0026rsquo;s docs.\nGenerate Form Request Micro Signature\nlucid make:request \u0026lt;name\u0026gt; \u0026lt;domain\u0026gt; Example\nlucid make:request UpdatePost post Generated class will be at app/Domains/Post/Requests/UpdatePost.php\nMonolith Signature\nlucid make:request \u0026lt;name\u0026gt; \u0026lt;domain\u0026gt; Example\nlucid make:request UpdatePost post Generated class will be at src/Domains/Post/Requests/UpdatePost.php\n\u0026lt;?php namespace App\\Domains\\Post\\Requests; use Illuminate\\Foundation\\Http\\FormRequest; class UpdatePost extends FormRequest { /** * Determine if the user is authorized to make this request. * * @return bool */ public function authorize() { return true; } /** * Get the validation rules that apply to the request. * * @return array */ public function rules() { return [ // ]; } } Requests as Unit Dispatchers One of the most powerful aspects of Lucid is the degree of code reuse it introduces. Specifically when dealing with Job and Operation classes which can be called from any custom dispatcher class.\nHere, we will be setting up UpdatePost Request class to authorize using AuthorizeUserOperation, and on after hook to run FaliedValidationJob.\nBenefit: Doing so would increase the degree of consistency and integrity in our application, where AuthorizeUserOperation could contain our consolidated authorization mechanism and can be called from any other class such as middleware to authoriza pre-flight. As for FaliedValidationJob it will ensure that all of our failed validations are handled consistently as expected.\n\u0026lt;?php namespace App\\Domains\\Post\\Requests; use Lucid\\Bus\\UnitDispatcher; use App\\Operations\\AuthorizeUserOperation; use Illuminate\\Foundation\\Http\\FormRequest; use App\\Domains\\Http\\Jobs\\FailedValidationJob; class UpdatePost extends FormRequest { use UnitDispatcher; public function authorize() { return $this-\u0026gt;run(new AuthorizeUserOperation()); } public function rules() { return [ \u0026#39;title\u0026#39; =\u0026gt; \u0026#39;required|unique:posts|max:255\u0026#39;, \u0026#39;body\u0026#39; =\u0026gt; \u0026#39;required\u0026#39;, ]; } public function withValidator($validator) { $validator-\u0026gt;after(function ($validator) { if ($this-\u0026gt;somethingElseIsInvalid()) { $this-\u0026gt;run(new FailedValidationJob($validator)); } }); } } Validation Jobs Another approach to validation is to validate using jobs. This is most useful with protocols other than HTTP (e.g. Console, AMQP, etc.), or if you simply choose not to use Requests.\nOur validation jobs would contain validation logic so it can be called whenever validation is required.\nStart by creating a job:\nlucid make:job ValidatePostUpdate post Then inject Illuminate\\Http\\Request and fill in your validation logic:\n\u0026lt;?php namespace App\\Domains\\Post\\Jobs; use Lucid\\Units\\Job; use Illuminate\\Http\\Request; class ValidatePostUpdateJob extends Job { public function handle(Request $request) { $validData = $request-\u0026gt;validate([ \u0026#39;title\u0026#39; =\u0026gt; \u0026#39;required|unique:posts|max:255\u0026#39;, \u0026#39;body\u0026#39; =\u0026gt; \u0026#39;required\u0026#39;, ]); return $validData; } } "},{"uri":"https://docs.lucidarch.dev/cli/","title":"CLI Reference","tags":[],"description":"","content":"The lucid command line interface companion for the Lucid Architecture.\nlucid is a set of methods to easily manage [create, delete] Lucid units such as Jobs, Operations, Features as well as Laravel\u0026rsquo;s own components such as Controller, Eloquent Model, Request and Policy; ensuring that they go where they belong and are generated with their test companion classes.\nSetup The executable binary can be found at ./vendor/bin/lucid after requiring lucid-arch/console.\nFor convenience you might want to address lucid directly instead of having to go through ./vendor/bin every time. To do that you need to add ./vendor/bin to your shell session\u0026rsquo;s $PATH. For the current session, run:\nexport PATH=\u0026#34;./vendor/bin:$PATH\u0026#34; However, it will only be available for the current session. To make it permanent, add it to your shell profile (~/.bash_profile, ~/.bashrc, ~/.zshrc) and you will be able to simply call lucid from the application\u0026rsquo;s root directory.\nUse list to view a list of all available commands:\nlucid list Also, just like in Artisan, every command includes a \u0026ldquo;help\u0026rdquo; screen describes the command\u0026rsquo;s available arguments and options. To view a help screen, precede the name of the command with help or use the --help option:\nlucid help make:feature # or lucid make:feature --help Commands make:service For Monolith projects only.\nCreate a new service in a monolith project.\nlucid make:service \u0026lt;name\u0026gt; # example lucid make:service HumanResources Will generate the following structure:\nsrc └── Services └── HumanResources ├── Providers ├── Console ├── Http ├── Features ├── Operations ├── Tests ├── database ├── routes └── resources make:controller Generate a controller class.\nMicro Signature\nlucid make:controller \u0026lt;controller\u0026gt; Example\nlucid make:controller Article Generated class will be at app/Http/Controllers/ArticleController.php\nMonolith Signature\nlucid make:controller \u0026lt;controller\u0026gt; \u0026lt;service\u0026gt; Example\nlucid make:controller Article Publishing Generated class will be at app/Services/Publishing/Http/Controllers/ArticleController.php\nEmpty Controller\nBy default it will generate an empty controller. To generate a resource controller use the --resource option:\nlucid make:controller \u0026lt;controller\u0026gt; [\u0026lt;service\u0026gt;] --resource make:feature Generate a Feature class.\nMicro Signature\nlucid make:feature \u0026lt;feature\u0026gt; Example\nlucid make:feature ListProducts Generated class will be at app/Features/ListProductsFeatures.php\nand its test at tests/Feature/ListProductsFeaturesTest.php\nMonolith Signature\nlucid make:feature \u0026lt;feature\u0026gt; \u0026lt;service\u0026gt; Example\nlucid make:feature ListProducts Commerce Generated class will be at app/Services/Commerce/Features/ListProductsFeatures.php\nand its test at tests/Feature/Services/Commerce/ListProductsFeaturesTest.php\nThe generated Feature class will automatically be suffixed with Feature, so there\u0026rsquo;s no need for it to be specified in the command.\nmake:job Generate a Job class.\nMicro Signature\nlucid make:job \u0026lt;job\u0026gt; \u0026lt;domain\u0026gt; {--Q|queue} Example\nlucid make:job FindProduct product Generated class will be at app/Domains/Product/Jobs/FindProductJob.php\nand its test at tests/Unit/Domains/Product/Jobs/FindProductJobTest.php\nMonolith Signature\nlucid make:job \u0026lt;job\u0026gt; \u0026lt;domain\u0026gt; {--Q|queue} Example\nlucid make:job FindProduct product Generated class will be at app/Domains/Product/Jobs/FindProductJob.php\nand its test at tests/Unit/Domains/Product/Jobs/FindProductJobTest.php\nThe generated Job class will automatically be suffixed with Job, so there\u0026rsquo;s no need for it to be specified in the command.\nmake:operation Micro Signature\nlucid make:operation \u0026lt;operation\u0026gt; {--Q|queue} Example\nlucid make:operation NotifySubscribers Generated class will be at app/Operations/NotifySubscribersOperation.php\nand its test at tests/Unit/Operations/NotifySubscribersOperationTest.php\nMonolith Signature\nlucid make:operation \u0026lt;operation\u0026gt; \u0026lt;service\u0026gt; {--Q|queue} Example\nlucid make:operation NotifySubscribers publishing Generated class will be at app/Services/Publishing/Operations/NotifySubscribersOperation.php\nand its test at tests/Unit/Services/Publishing/Operations/NotifySubscribersOperationTest.php\nThe generated Operation class will automatically be suffixed with Operation, so there\u0026rsquo;s no need for it to be specified in the command.\nmake:migration Micro Signature\nlucid make:migration \u0026lt;migration\u0026gt; Example\nlucid make:migration create_articles_table Generated file will be at database/migrations/2020_10_28_180253_create_articles_table.php\nMonolith Signature\nlucid make:migration \u0026lt;migration\u0026gt; \u0026lt;service\u0026gt; Example\nlucid make:migration create_articles_table publishing Generated file will be at app/Services/Publishing/database/migrations/2020_10_28_180253_create_articles_table.php\nmake:model Generate an Eloquent model class.\nSignature\nlucid make:model \u0026lt;name\u0026gt; Example\nlucid make:model Product Generated model file will be at app/Data/Product.php.\nmake:request Micro lucid make:request \u0026lt;request\u0026gt; \u0026lt;domain\u0026gt; Generated file will be at app/Domains/\u0026lt;domain\u0026gt;/Requests/\u0026lt;request\u0026gt;.\nMonolith lucid make:request \u0026lt;request\u0026gt; \u0026lt;domain\u0026gt; Generated file will be at app/Domains/\u0026lt;domain\u0026gt;/Requests/\u0026lt;request\u0026gt;.\nmake:policy Micro lucid make:policy \u0026lt;policy\u0026gt; Generated file will be at app/Http/Policies/\u0026lt;policy\u0026gt;.\nMonolith lucid make:policy \u0026lt;policy\u0026gt; \u0026lt;service\u0026gt; Generated file will be at app/Services/\u0026lt;service\u0026gt;/Http/Policies/\u0026lt;policy\u0026gt;.\nlist:services List the services in a monolith project\nFor Monolith projects only.\nlucid list:services +------------+------------+-------------------------+ | Service | Slug | Path | +------------+------------+-------------------------+ | Commerce | commerce | app/Services/Commerce | | Publishing | publishing | app/Services/Publishing | | Admin | admin | app/Services/Admin | +------------+------------+-------------------------+ list:features lucid list:features delete:service For Monolith projects only.\nlucid delete service \u0026lt;name\u0026gt; delete:feature lucid delete:feature \u0026lt;feature\u0026gt; [\u0026lt;service\u0026gt;] delete:job lucid delete:job \u0026lt;job\u0026gt; \u0026lt;domain\u0026gt; delete:model delete:model \u0026lt;model\u0026gt; delete:request lucid delete:request \u0026lt;request\u0026gt; [\u0026lt;service\u0026gt;] delete:policy delete:policy \u0026lt;policy\u0026gt; [\u0026lt;service\u0026gt;] "},{"uri":"https://docs.lucidarch.dev/","title":"","tags":[],"description":"","content":" "}]